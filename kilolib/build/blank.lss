
build/blank.elf:     format de fichier elf32-avr


Déassemblage de la section .text :

00000000 <__vectors>:
       0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
       4:	0c 94 6f 00 	jmp	0xde	; 0xde <__bad_interrupt>
       8:	0c 94 6f 00 	jmp	0xde	; 0xde <__bad_interrupt>
       c:	0c 94 6f 00 	jmp	0xde	; 0xde <__bad_interrupt>
      10:	0c 94 6f 00 	jmp	0xde	; 0xde <__bad_interrupt>
      14:	0c 94 6f 00 	jmp	0xde	; 0xde <__bad_interrupt>
      18:	0c 94 6a 01 	jmp	0x2d4	; 0x2d4 <__vector_6>
      1c:	0c 94 6f 00 	jmp	0xde	; 0xde <__bad_interrupt>
      20:	0c 94 6f 00 	jmp	0xde	; 0xde <__bad_interrupt>
      24:	0c 94 6f 00 	jmp	0xde	; 0xde <__bad_interrupt>
      28:	0c 94 6f 00 	jmp	0xde	; 0xde <__bad_interrupt>
      2c:	0c 94 db 08 	jmp	0x11b6	; 0x11b6 <__vector_11>
      30:	0c 94 6f 00 	jmp	0xde	; 0xde <__bad_interrupt>
      34:	0c 94 6f 00 	jmp	0xde	; 0xde <__bad_interrupt>
      38:	0c 94 2e 08 	jmp	0x105c	; 0x105c <__vector_14>
      3c:	0c 94 6f 00 	jmp	0xde	; 0xde <__bad_interrupt>
      40:	0c 94 6f 00 	jmp	0xde	; 0xde <__bad_interrupt>
      44:	0c 94 6f 00 	jmp	0xde	; 0xde <__bad_interrupt>
      48:	0c 94 6f 00 	jmp	0xde	; 0xde <__bad_interrupt>
      4c:	0c 94 6f 00 	jmp	0xde	; 0xde <__bad_interrupt>
      50:	0c 94 6f 00 	jmp	0xde	; 0xde <__bad_interrupt>
      54:	0c 94 6f 00 	jmp	0xde	; 0xde <__bad_interrupt>
      58:	0c 94 6f 00 	jmp	0xde	; 0xde <__bad_interrupt>
      5c:	0c 94 fd 08 	jmp	0x11fa	; 0x11fa <__vector_23>
      60:	0c 94 6f 00 	jmp	0xde	; 0xde <__bad_interrupt>
      64:	0c 94 6f 00 	jmp	0xde	; 0xde <__bad_interrupt>
      68:	9a 02       	muls	r25, r26
      6a:	4a 02       	muls	r20, r26
      6c:	18 02       	muls	r17, r24
      6e:	01 02       	muls	r16, r17
      70:	f6 01       	movw	r30, r12
      72:	d6 01       	movw	r26, r12
      74:	32 03       	mulsu	r19, r18
      76:	99 0a       	sbc	r9, r25
      78:	3d 09       	sbc	r19, r13
      7a:	3d 09       	sbc	r19, r13
      7c:	96 0a       	sbc	r9, r22
      7e:	93 0a       	sbc	r9, r19
      80:	8f 0a       	sbc	r8, r31
      82:	8b 0a       	sbc	r8, r27
      84:	87 0a       	sbc	r8, r23
      86:	6f 0a       	sbc	r6, r31
      88:	43 0a       	sbc	r4, r19
      8a:	1d 0a       	sbc	r1, r29

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d8 e0       	ldi	r29, 0x08	; 8
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <wdt_init>:
#ifndef BOOTLOADER
// Ensure that wdt is inactive after system reset.
void wdt_init(void) __attribute__((naked)) __attribute__((section(".init3")));

void wdt_init(void) {
    MCUSR = 0;
      98:	14 be       	out	0x34, r1	; 52
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
      9a:	0f b6       	in	r0, 0x3f	; 63
      9c:	f8 94       	cli
      9e:	a8 95       	wdr
      a0:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
      a4:	88 61       	ori	r24, 0x18	; 24
      a6:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
      aa:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>
      ae:	0f be       	out	0x3f, r0	; 63

000000b0 <__do_copy_data>:
      b0:	11 e0       	ldi	r17, 0x01	; 1
      b2:	a0 e0       	ldi	r26, 0x00	; 0
      b4:	b1 e0       	ldi	r27, 0x01	; 1
      b6:	e0 e0       	ldi	r30, 0x00	; 0
      b8:	ff e1       	ldi	r31, 0x1F	; 31
      ba:	02 c0       	rjmp	.+4      	; 0xc0 <__do_copy_data+0x10>
      bc:	05 90       	lpm	r0, Z+
      be:	0d 92       	st	X+, r0
      c0:	ae 30       	cpi	r26, 0x0E	; 14
      c2:	b1 07       	cpc	r27, r17
      c4:	d9 f7       	brne	.-10     	; 0xbc <__do_copy_data+0xc>

000000c6 <__do_clear_bss>:
      c6:	21 e0       	ldi	r18, 0x01	; 1
      c8:	ae e0       	ldi	r26, 0x0E	; 14
      ca:	b1 e0       	ldi	r27, 0x01	; 1
      cc:	01 c0       	rjmp	.+2      	; 0xd0 <.do_clear_bss_start>

000000ce <.do_clear_bss_loop>:
      ce:	1d 92       	st	X+, r1

000000d0 <.do_clear_bss_start>:
      d0:	a3 37       	cpi	r26, 0x73	; 115
      d2:	b2 07       	cpc	r27, r18
      d4:	e1 f7       	brne	.-8      	; 0xce <.do_clear_bss_loop>
      d6:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <main>
      da:	0c 94 7e 0f 	jmp	0x1efc	; 0x1efc <_exit>

000000de <__bad_interrupt>:
      de:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000e2 <setup>:
#include "kilolib.h"

void setup() {
      e2:	08 95       	ret

000000e4 <loop>:
    // put your setup code here, will be run once at the beginning
}

void loop() {
    // put your main code here, will be run repeatedly
    set_color(RGB(1,0,0));
      e4:	81 e0       	ldi	r24, 0x01	; 1
      e6:	0e 94 b7 08 	call	0x116e	; 0x116e <set_color>
    delay(100);
      ea:	84 e6       	ldi	r24, 0x64	; 100
      ec:	90 e0       	ldi	r25, 0x00	; 0
      ee:	0e 94 6b 04 	call	0x8d6	; 0x8d6 <delay>
    set_color(RGB(0,1,0));
      f2:	84 e0       	ldi	r24, 0x04	; 4
      f4:	0e 94 b7 08 	call	0x116e	; 0x116e <set_color>
    delay(100);
      f8:	84 e6       	ldi	r24, 0x64	; 100
      fa:	90 e0       	ldi	r25, 0x00	; 0
      fc:	0c 94 6b 04 	jmp	0x8d6	; 0x8d6 <delay>

00000100 <message_rx_dummy>:
/* Number of clock cycles for an entire message. */
#define rx_msgcycles (11*rx_bitcycles)

typedef void (*AddressPointer_t)(void) __attribute__ ((noreturn));

void message_rx_dummy(message_t *m, distance_measurement_t *d) { }
     100:	08 95       	ret

00000102 <message_tx_dummy>:
message_t *message_tx_dummy() { return NULL; }
     102:	80 e0       	ldi	r24, 0x00	; 0
     104:	90 e0       	ldi	r25, 0x00	; 0
     106:	08 95       	ret

00000108 <message_tx_success_dummy>:
void message_tx_success_dummy() {}
     108:	08 95       	ret

0000010a <kilo_init>:
    RUNNING,
    CHARGING,
    MOVING
} kilo_state;

void kilo_init() {
     10a:	df 92       	push	r13
     10c:	ef 92       	push	r14
     10e:	ff 92       	push	r15
     110:	0f 93       	push	r16
     112:	1f 93       	push	r17
     114:	cf 93       	push	r28
     116:	df 93       	push	r29
    cli();
     118:	f8 94       	cli

    ports_off();
     11a:	14 b8       	out	0x04, r1	; 4
     11c:	17 b8       	out	0x07, r1	; 7
     11e:	1a b8       	out	0x0a, r1	; 10
     120:	15 b8       	out	0x05, r1	; 5
     122:	18 b8       	out	0x08, r1	; 8
     124:	1b b8       	out	0x0b, r1	; 11
    ports_on();
     126:	52 9a       	sbi	0x0a, 2	; 10
     128:	5a 9a       	sbi	0x0b, 2	; 11
    tx_timer_setup();
     12a:	14 bc       	out	0x24, r1	; 36
     12c:	85 e0       	ldi	r24, 0x05	; 5
     12e:	85 bd       	out	0x25, r24	; 37
     130:	8f ef       	ldi	r24, 0xFF	; 255
     132:	87 bd       	out	0x27, r24	; 39
     134:	82 e0       	ldi	r24, 0x02	; 2
     136:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__DATA_REGION_ORIGIN__+0xe>
    rx_timer_setup();
     13a:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
     13e:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
     142:	2f e8       	ldi	r18, 0x8F	; 143
     144:	3b e0       	ldi	r19, 0x0B	; 11
     146:	30 93 89 00 	sts	0x0089, r19	; 0x800089 <__DATA_REGION_ORIGIN__+0x29>
     14a:	20 93 88 00 	sts	0x0088, r18	; 0x800088 <__DATA_REGION_ORIGIN__+0x28>
     14e:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__DATA_REGION_ORIGIN__+0xf>
    motors_setup();
     152:	53 98       	cbi	0x0a, 3	; 10
     154:	23 98       	cbi	0x04, 3	; 4
     156:	91 ea       	ldi	r25, 0xA1	; 161
     158:	90 93 b0 00 	sts	0x00B0, r25	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
     15c:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
     160:	10 92 b4 00 	sts	0x00B4, r1	; 0x8000b4 <__DATA_REGION_ORIGIN__+0x54>
     164:	10 92 b3 00 	sts	0x00B3, r1	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
    acomp_setup();
     168:	8b e0       	ldi	r24, 0x0B	; 11
     16a:	80 bf       	out	0x30, r24	; 48
     16c:	83 e0       	ldi	r24, 0x03	; 3
     16e:	80 93 7f 00 	sts	0x007F, r24	; 0x80007f <__DATA_REGION_ORIGIN__+0x1f>
    adc_setup();
     172:	86 e0       	ldi	r24, 0x06	; 6
     174:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__DATA_REGION_ORIGIN__+0x1c>
     178:	83 e8       	ldi	r24, 0x83	; 131
     17a:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
     17e:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
     182:	80 64       	ori	r24, 0x40	; 64
     184:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
     188:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
     18c:	86 fd       	sbrc	r24, 6
     18e:	fc cf       	rjmp	.-8      	; 0x188 <kilo_init+0x7e>
    adc_trigger_high_gain();
     190:	10 92 7c 00 	sts	0x007C, r1	; 0x80007c <__DATA_REGION_ORIGIN__+0x1c>
     194:	83 ea       	ldi	r24, 0xA3	; 163
     196:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
     19a:	81 e0       	ldi	r24, 0x01	; 1
     19c:	80 93 7b 00 	sts	0x007B, r24	; 0x80007b <__DATA_REGION_ORIGIN__+0x1b>

    uint8_t osccal = eeprom_read_byte(EEPROM_OSCCAL);
     1a0:	81 e0       	ldi	r24, 0x01	; 1
     1a2:	90 e0       	ldi	r25, 0x00	; 0
     1a4:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <eeprom_read_byte>
    if (osccal != 0xFF)
     1a8:	8f 3f       	cpi	r24, 0xFF	; 255
     1aa:	11 f0       	breq	.+4      	; 0x1b0 <kilo_init+0xa6>
        OSCCAL = osccal;
     1ac:	80 93 66 00 	sts	0x0066, r24	; 0x800066 <__DATA_REGION_ORIGIN__+0x6>

    rx_busy = 0;
     1b0:	10 92 3b 01 	sts	0x013B, r1	; 0x80013b <rx_busy>
    rx_leadingbit = 1;
     1b4:	c1 e0       	ldi	r28, 0x01	; 1
     1b6:	c0 93 14 01 	sts	0x0114, r28	; 0x800114 <rx_leadingbit>
    rx_leadingbyte = 1;
     1ba:	c0 93 58 01 	sts	0x0158, r28	; 0x800158 <rx_leadingbyte>
    rx_byteindex = 0;
     1be:	10 92 32 01 	sts	0x0132, r1	; 0x800132 <rx_byteindex>
    rx_bytevalue = 0;
     1c2:	10 92 6c 01 	sts	0x016C, r1	; 0x80016c <rx_bytevalue>
#ifndef BOOTLOADER
    tx_mask = eeprom_read_byte(EEPROM_TXMASK);
     1c6:	80 e9       	ldi	r24, 0x90	; 144
     1c8:	90 e0       	ldi	r25, 0x00	; 0
     1ca:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <eeprom_read_byte>
     1ce:	80 93 31 01 	sts	0x0131, r24	; 0x800131 <tx_mask>
    if (tx_mask & ~TX_MASK_MAX)
     1d2:	80 91 31 01 	lds	r24, 0x0131	; 0x800131 <tx_mask>
     1d6:	88 73       	andi	r24, 0x38	; 56
     1d8:	11 f0       	breq	.+4      	; 0x1de <kilo_init+0xd4>
        tx_mask = TX_MASK_MIN;
     1da:	c0 93 31 01 	sts	0x0131, r28	; 0x800131 <tx_mask>
    tx_clock = 0;
     1de:	10 92 5c 01 	sts	0x015C, r1	; 0x80015c <tx_clock+0x1>
     1e2:	10 92 5b 01 	sts	0x015B, r1	; 0x80015b <tx_clock>
    tx_increment = 255;
     1e6:	8f ef       	ldi	r24, 0xFF	; 255
     1e8:	90 e0       	ldi	r25, 0x00	; 0
     1ea:	90 93 5a 01 	sts	0x015A, r25	; 0x80015a <tx_increment+0x1>
     1ee:	80 93 59 01 	sts	0x0159, r24	; 0x800159 <tx_increment>
    kilo_ticks = 0;
     1f2:	10 92 37 01 	sts	0x0137, r1	; 0x800137 <kilo_ticks>
     1f6:	10 92 38 01 	sts	0x0138, r1	; 0x800138 <kilo_ticks+0x1>
     1fa:	10 92 39 01 	sts	0x0139, r1	; 0x800139 <kilo_ticks+0x2>
     1fe:	10 92 3a 01 	sts	0x013A, r1	; 0x80013a <kilo_ticks+0x3>
    kilo_state = IDLE;
     202:	81 e0       	ldi	r24, 0x01	; 1
     204:	80 93 13 01 	sts	0x0113, r24	; 0x800113 <kilo_state>
    kilo_tx_period = 3906;
     208:	82 e4       	ldi	r24, 0x42	; 66
     20a:	9f e0       	ldi	r25, 0x0F	; 15
     20c:	90 93 6b 01 	sts	0x016B, r25	; 0x80016b <kilo_tx_period+0x1>
     210:	80 93 6a 01 	sts	0x016A, r24	; 0x80016a <kilo_tx_period>
    kilo_uid = eeprom_read_byte(EEPROM_UID) | eeprom_read_byte(EEPROM_UID+1)<<8;
     214:	80 eb       	ldi	r24, 0xB0	; 176
     216:	90 e0       	ldi	r25, 0x00	; 0
     218:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <eeprom_read_byte>
     21c:	c8 2f       	mov	r28, r24
     21e:	81 eb       	ldi	r24, 0xB1	; 177
     220:	90 e0       	ldi	r25, 0x00	; 0
     222:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <eeprom_read_byte>
     226:	2c 2f       	mov	r18, r28
     228:	30 e0       	ldi	r19, 0x00	; 0
     22a:	38 2b       	or	r19, r24
     22c:	30 93 6e 01 	sts	0x016E, r19	; 0x80016e <kilo_uid+0x1>
     230:	20 93 6d 01 	sts	0x016D, r18	; 0x80016d <kilo_uid>
    kilo_turn_left = eeprom_read_byte(EEPROM_LEFT_ROTATE);
     234:	85 e0       	ldi	r24, 0x05	; 5
     236:	90 e0       	ldi	r25, 0x00	; 0
     238:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <eeprom_read_byte>
     23c:	80 93 72 01 	sts	0x0172, r24	; 0x800172 <kilo_turn_left>
    kilo_turn_right = eeprom_read_byte(EEPROM_RIGHT_ROTATE);
     240:	89 e0       	ldi	r24, 0x09	; 9
     242:	90 e0       	ldi	r25, 0x00	; 0
     244:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <eeprom_read_byte>
     248:	80 93 5d 01 	sts	0x015D, r24	; 0x80015d <kilo_turn_right>
    kilo_straight_left = eeprom_read_byte(EEPROM_LEFT_STRAIGHT);
     24c:	8c e0       	ldi	r24, 0x0C	; 12
     24e:	90 e0       	ldi	r25, 0x00	; 0
     250:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <eeprom_read_byte>
     254:	80 93 70 01 	sts	0x0170, r24	; 0x800170 <kilo_straight_left>
    kilo_straight_right = eeprom_read_byte(EEPROM_RIGHT_STRAIGHT);
     258:	84 e1       	ldi	r24, 0x14	; 20
     25a:	90 e0       	ldi	r25, 0x00	; 0
     25c:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <eeprom_read_byte>
     260:	80 93 71 01 	sts	0x0171, r24	; 0x800171 <kilo_straight_right>
     264:	5c e3       	ldi	r21, 0x3C	; 60
     266:	e5 2e       	mov	r14, r21
     268:	51 e0       	ldi	r21, 0x01	; 1
     26a:	f5 2e       	mov	r15, r21
     26c:	05 e1       	ldi	r16, 0x15	; 21
     26e:	11 e0       	ldi	r17, 0x01	; 1
     270:	c0 e2       	ldi	r28, 0x20	; 32
     272:	d0 e0       	ldi	r29, 0x00	; 0

    uint8_t i;
    for (i=0; i<14; i++) {
        kilo_irlow[i]=(eeprom_read_byte(EEPROM_IRLOW + i*2) <<8) | eeprom_read_byte(EEPROM_IRLOW + i*2+1);
     274:	ce 01       	movw	r24, r28
     276:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <eeprom_read_byte>
     27a:	d8 2e       	mov	r13, r24
     27c:	ce 01       	movw	r24, r28
     27e:	01 96       	adiw	r24, 0x01	; 1
     280:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <eeprom_read_byte>
     284:	2d 2d       	mov	r18, r13
     286:	30 e0       	ldi	r19, 0x00	; 0
     288:	32 2f       	mov	r19, r18
     28a:	22 27       	eor	r18, r18
     28c:	28 2b       	or	r18, r24
     28e:	f7 01       	movw	r30, r14
     290:	21 93       	st	Z+, r18
     292:	31 93       	st	Z+, r19
     294:	7f 01       	movw	r14, r30
        kilo_irhigh[i]=(eeprom_read_byte(EEPROM_IRHIGH + i*2) <<8) | eeprom_read_byte(EEPROM_IRHIGH + i*2+1);
     296:	ce 01       	movw	r24, r28
     298:	c0 96       	adiw	r24, 0x30	; 48
     29a:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <eeprom_read_byte>
     29e:	d8 2e       	mov	r13, r24
     2a0:	ce 01       	movw	r24, r28
     2a2:	c1 96       	adiw	r24, 0x31	; 49
     2a4:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <eeprom_read_byte>
     2a8:	2d 2d       	mov	r18, r13
     2aa:	30 e0       	ldi	r19, 0x00	; 0
     2ac:	32 2f       	mov	r19, r18
     2ae:	22 27       	eor	r18, r18
     2b0:	28 2b       	or	r18, r24
     2b2:	f8 01       	movw	r30, r16
     2b4:	21 93       	st	Z+, r18
     2b6:	31 93       	st	Z+, r19
     2b8:	8f 01       	movw	r16, r30
     2ba:	22 96       	adiw	r28, 0x02	; 2
    kilo_turn_right = eeprom_read_byte(EEPROM_RIGHT_ROTATE);
    kilo_straight_left = eeprom_read_byte(EEPROM_LEFT_STRAIGHT);
    kilo_straight_right = eeprom_read_byte(EEPROM_RIGHT_STRAIGHT);

    uint8_t i;
    for (i=0; i<14; i++) {
     2bc:	cc 33       	cpi	r28, 0x3C	; 60
     2be:	d1 05       	cpc	r29, r1
     2c0:	c9 f6       	brne	.-78     	; 0x274 <kilo_init+0x16a>
        kilo_irlow[i]=(eeprom_read_byte(EEPROM_IRLOW + i*2) <<8) | eeprom_read_byte(EEPROM_IRLOW + i*2+1);
        kilo_irhigh[i]=(eeprom_read_byte(EEPROM_IRHIGH + i*2) <<8) | eeprom_read_byte(EEPROM_IRHIGH + i*2+1);
    }
#endif
    sei();
     2c2:	78 94       	sei
}
     2c4:	df 91       	pop	r29
     2c6:	cf 91       	pop	r28
     2c8:	1f 91       	pop	r17
     2ca:	0f 91       	pop	r16
     2cc:	ff 90       	pop	r15
     2ce:	ef 90       	pop	r14
     2d0:	df 90       	pop	r13
     2d2:	08 95       	ret

000002d4 <__vector_6>:

/**
 * Watchdog timer interrupt.
 * Used to wakeup from low power sleep mode.
 */
ISR(WDT_vect) {
     2d4:	1f 92       	push	r1
     2d6:	0f 92       	push	r0
     2d8:	0f b6       	in	r0, 0x3f	; 63
     2da:	0f 92       	push	r0
     2dc:	11 24       	eor	r1, r1
     2de:	8f 93       	push	r24
     2e0:	0f b6       	in	r0, 0x3f	; 63
     2e2:	f8 94       	cli
     2e4:	a8 95       	wdr
     2e6:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     2ea:	88 61       	ori	r24, 0x18	; 24
     2ec:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
     2f0:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>
     2f4:	0f be       	out	0x3f, r0	; 63
    wdt_disable();
}
     2f6:	8f 91       	pop	r24
     2f8:	0f 90       	pop	r0
     2fa:	0f be       	out	0x3f, r0	; 63
     2fc:	0f 90       	pop	r0
     2fe:	1f 90       	pop	r1
     300:	18 95       	reti

00000302 <estimate_voltage>:
static volatile uint8_t prev_motion = MOVE_STOP, cur_motion = MOVE_STOP;

/*
 * This function estimates the voltage of the battery by taking the maximum of N_READINGS_VOLTAGE measurements. This function triggers high gain at the end if trigger_high_gain = 1. This means the next voltage reading will not be valid, but all the other functions that use the adc converter will work normally (e.g., distance estimation). This is useful in the RUNNING state. If trigger_high_gain = 0, the next voltage reading will be valid, but not the rest of functions using the adc converter (useful when not in the RUNNING state).
 */
int16_t estimate_voltage(uint8_t trigger_high_gain){
     302:	2a e0       	ldi	r18, 0x0A	; 10

    uint8_t i;
    int16_t voltage;
    int16_t estimated_voltage = -1;
     304:	ef ef       	ldi	r30, 0xFF	; 255
     306:	ff ef       	ldi	r31, 0xFF	; 255

int16_t get_voltage() {
    int16_t voltage=-1;
    if (!rx_busy) {
        cli();                                    // disable interrupts
        adc_setup_conversion(6);
     308:	66 e0       	ldi	r22, 0x06	; 6
     30a:	33 e8       	ldi	r19, 0x83	; 131
    seed = s;
}

int16_t get_voltage() {
    int16_t voltage=-1;
    if (!rx_busy) {
     30c:	90 91 3b 01 	lds	r25, 0x013B	; 0x80013b <rx_busy>
     310:	91 11       	cpse	r25, r1
     312:	2b c0       	rjmp	.+86     	; 0x36a <estimate_voltage+0x68>
        cli();                                    // disable interrupts
     314:	f8 94       	cli
        adc_setup_conversion(6);
     316:	60 93 7c 00 	sts	0x007C, r22	; 0x80007c <__DATA_REGION_ORIGIN__+0x1c>
     31a:	30 93 7a 00 	sts	0x007A, r19	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
        adc_start_conversion();
     31e:	90 91 7a 00 	lds	r25, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
     322:	90 64       	ori	r25, 0x40	; 64
     324:	90 93 7a 00 	sts	0x007A, r25	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
        adc_finish_conversion();
     328:	90 91 7a 00 	lds	r25, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
     32c:	96 fd       	sbrc	r25, 6
     32e:	fc cf       	rjmp	.-8      	; 0x328 <estimate_voltage+0x26>
        voltage = ADCW;                           // store AD result
     330:	40 91 78 00 	lds	r20, 0x0078	; 0x800078 <__DATA_REGION_ORIGIN__+0x18>
     334:	50 91 79 00 	lds	r21, 0x0079	; 0x800079 <__DATA_REGION_ORIGIN__+0x19>
        
        //adc_trigger_high_gain();                     // set AD to measure high gain (for distance sensing)
            
        sei();                                    // reenable interrupts
     338:	78 94       	sei

    for(i = 0; i < N_READINGS_VOLTAGE; i++){

        voltage = get_voltage();
    
        if(voltage <= HIGH_VOLTAGE_THRESHOLD && voltage > estimated_voltage){
     33a:	4d 3c       	cpi	r20, 0xCD	; 205
     33c:	92 e0       	ldi	r25, 0x02	; 2
     33e:	59 07       	cpc	r21, r25
     340:	24 f4       	brge	.+8      	; 0x34a <estimate_voltage+0x48>
     342:	e4 17       	cp	r30, r20
     344:	f5 07       	cpc	r31, r21
     346:	0c f4       	brge	.+2      	; 0x34a <estimate_voltage+0x48>
     348:	fa 01       	movw	r30, r20
     34a:	21 50       	subi	r18, 0x01	; 1

    uint8_t i;
    int16_t voltage;
    int16_t estimated_voltage = -1;

    for(i = 0; i < N_READINGS_VOLTAGE; i++){
     34c:	f9 f6       	brne	.-66     	; 0x30c <estimate_voltage+0xa>
            estimated_voltage = voltage;
          
        }
    }

    if(trigger_high_gain){
     34e:	88 23       	and	r24, r24
     350:	51 f0       	breq	.+20     	; 0x366 <estimate_voltage+0x64>
        cli();
     352:	f8 94       	cli
        adc_trigger_high_gain();
     354:	10 92 7c 00 	sts	0x007C, r1	; 0x80007c <__DATA_REGION_ORIGIN__+0x1c>
     358:	83 ea       	ldi	r24, 0xA3	; 163
     35a:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
     35e:	81 e0       	ldi	r24, 0x01	; 1
     360:	80 93 7b 00 	sts	0x007B, r24	; 0x80007b <__DATA_REGION_ORIGIN__+0x1b>
        sei();
     364:	78 94       	sei
    }

    return estimated_voltage;
}
     366:	cf 01       	movw	r24, r30
     368:	08 95       	ret
void rand_seed(uint8_t s) {
    seed = s;
}

int16_t get_voltage() {
    int16_t voltage=-1;
     36a:	4f ef       	ldi	r20, 0xFF	; 255
     36c:	5f ef       	ldi	r21, 0xFF	; 255
     36e:	e9 cf       	rjmp	.-46     	; 0x342 <estimate_voltage+0x40>

00000370 <kilo_start>:

    return estimated_voltage;
}


void kilo_start(void (*setup)(void), void (*loop)(void)) {
     370:	7c 01       	movw	r14, r24
     372:	8b 01       	movw	r16, r22

    uint8_t has_setup = 0;
     374:	d1 2c       	mov	r13, r1
    }
}

void set_motors(uint8_t ccw, uint8_t cw) {
    OCR2A = ccw;
    OCR2B = cw;
     376:	99 24       	eor	r9, r9
     378:	9a 94       	dec	r9

int16_t get_voltage() {
    int16_t voltage=-1;
    if (!rx_busy) {
        cli();                                    // disable interrupts
        adc_setup_conversion(6);
     37a:	d6 e0       	ldi	r29, 0x06	; 6
     37c:	c3 e8       	ldi	r28, 0x83	; 131
        }
    }

    if(trigger_high_gain){
        cli();
        adc_trigger_high_gain();
     37e:	83 ea       	ldi	r24, 0xA3	; 163
     380:	58 2e       	mov	r5, r24
     382:	88 24       	eor	r8, r8
     384:	83 94       	inc	r8
void rand_seed(uint8_t s) {
    seed = s;
}

int16_t get_voltage() {
    int16_t voltage=-1;
     386:	66 24       	eor	r6, r6
     388:	6a 94       	dec	r6
     38a:	76 2c       	mov	r7, r6
                if (!has_setup) {
                    setup();
                    has_setup = 1;
                }
                is_in_low_voltage = 0;
                kilo_state = RUNNING;
     38c:	24 e0       	ldi	r18, 0x04	; 4
     38e:	a2 2e       	mov	r10, r18
				: "r0"
		);
	}
	else
	{
		__asm__ __volatile__ (
     390:	38 e1       	ldi	r19, 0x18	; 24
     392:	b3 2e       	mov	r11, r19
     394:	49 e2       	ldi	r20, 0x29	; 41
     396:	c4 2e       	mov	r12, r20

    uint8_t has_setup = 0;

    while (1) {

        switch(kilo_state) {
     398:	e0 91 13 01 	lds	r30, 0x0113	; 0x800113 <kilo_state>
     39c:	f0 e0       	ldi	r31, 0x00	; 0
     39e:	e7 30       	cpi	r30, 0x07	; 7
     3a0:	f1 05       	cpc	r31, r1
     3a2:	d0 f7       	brcc	.-12     	; 0x398 <kilo_start+0x28>
     3a4:	ec 5c       	subi	r30, 0xCC	; 204
     3a6:	ff 4f       	sbci	r31, 0xFF	; 255
     3a8:	0c 94 7f 0c 	jmp	0x18fe	; 0x18fe <__tablejump2__>
                else
                    set_color(RGB(3,0,0));

                break;
            case CHARGING:
                is_in_low_voltage = 0;
     3ac:	10 92 0f 01 	sts	0x010F, r1	; 0x80010f <is_in_low_voltage>
                if (is_charging()) {
     3b0:	48 99       	sbic	0x09, 0	; 9
     3b2:	51 c1       	rjmp	.+674    	; 0x656 <__LOCK_REGION_LENGTH__+0x256>

#endif

void set_color(uint8_t rgb) {
    if (rgb&(1<<0))
        DDRD |= (1<<5);
     3b4:	55 9a       	sbi	0x0a, 5	; 10
        DDRD &= ~(1<<5);

    if (rgb&(1<<1))
        DDRD |= (1<<4);
    else
        DDRD &= ~(1<<4);
     3b6:	54 98       	cbi	0x0a, 4	; 10

    if (rgb&(1<<2))
        DDRC |= (1<<3);
    else
        DDRC &= ~(1<<3);
     3b8:	3b 98       	cbi	0x07, 3	; 7

    if (rgb&(1<<3))
        DDRC |= (1<<2);
    else
        DDRC &= ~(1<<2);
     3ba:	3a 98       	cbi	0x07, 2	; 7

    if (rgb&(1<<4))
        DDRC |= (1<<5);
    else
        DDRC &= ~(1<<5);
     3bc:	3d 98       	cbi	0x07, 5	; 7

    if (rgb&(1<<5))
        DDRC |= (1<<4);
    else
        DDRC &= ~(1<<4);
     3be:	3c 98       	cbi	0x07, 4	; 7
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     3c0:	8f ec       	ldi	r24, 0xCF	; 207
     3c2:	97 e0       	ldi	r25, 0x07	; 7
     3c4:	01 97       	sbiw	r24, 0x01	; 1
     3c6:	f1 f7       	brne	.-4      	; 0x3c4 <kilo_start+0x54>
     3c8:	00 c0       	rjmp	.+0      	; 0x3ca <kilo_start+0x5a>
     3ca:	00 00       	nop

void set_color(uint8_t rgb) {
    if (rgb&(1<<0))
        DDRD |= (1<<5);
    else
        DDRD &= ~(1<<5);
     3cc:	55 98       	cbi	0x0a, 5	; 10

    if (rgb&(1<<1))
        DDRD |= (1<<4);
    else
        DDRD &= ~(1<<4);
     3ce:	54 98       	cbi	0x0a, 4	; 10

    if (rgb&(1<<2))
        DDRC |= (1<<3);
    else
        DDRC &= ~(1<<3);
     3d0:	3b 98       	cbi	0x07, 3	; 7

    if (rgb&(1<<3))
        DDRC |= (1<<2);
    else
        DDRC &= ~(1<<2);
     3d2:	3a 98       	cbi	0x07, 2	; 7

    if (rgb&(1<<4))
        DDRC |= (1<<5);
    else
        DDRC &= ~(1<<5);
     3d4:	3d 98       	cbi	0x07, 5	; 7

    if (rgb&(1<<5))
        DDRC |= (1<<4);
    else
        DDRC &= ~(1<<4);
     3d6:	3c 98       	cbi	0x07, 4	; 7
     3d8:	9f ef       	ldi	r25, 0xFF	; 255
     3da:	e1 ee       	ldi	r30, 0xE1	; 225
     3dc:	f4 e0       	ldi	r31, 0x04	; 4
     3de:	91 50       	subi	r25, 0x01	; 1
     3e0:	e0 40       	sbci	r30, 0x00	; 0
     3e2:	f0 40       	sbci	r31, 0x00	; 0
     3e4:	e1 f7       	brne	.-8      	; 0x3de <kilo_start+0x6e>
     3e6:	00 c0       	rjmp	.+0      	; 0x3e8 <kilo_start+0x78>
     3e8:	00 00       	nop
     3ea:	d6 cf       	rjmp	.-84     	; 0x398 <kilo_start+0x28>
                }
                is_in_low_voltage = 0;
                kilo_state = RUNNING;
            case RUNNING:

                if(rx_busy){
     3ec:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <rx_busy>
     3f0:	81 11       	cpse	r24, r1
     3f2:	1b c0       	rjmp	.+54     	; 0x42a <__LOCK_REGION_LENGTH__+0x2a>

                    loop();

                }

                else if(is_in_low_voltage < N_REPETITIONS_LOW_VOLTAGE){
     3f4:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <is_in_low_voltage>
     3f8:	85 30       	cpi	r24, 0x05	; 5
     3fa:	80 f0       	brcs	.+32     	; 0x41c <__LOCK_REGION_LENGTH__+0x1c>

                    loop();

                }
                else{
                    kilo_state = SLEEPING;
     3fc:	10 92 13 01 	sts	0x0113, r1	; 0x800113 <kilo_state>
     400:	cb cf       	rjmp	.-106    	; 0x398 <kilo_start+0x28>
                } else
                    set_color(RGB(0,0,0));

                break;
            case SETUP:
                if (!has_setup) {
     402:	dd 20       	and	r13, r13
     404:	09 f4       	brne	.+2      	; 0x408 <__LOCK_REGION_LENGTH__+0x8>
     406:	98 c1       	rjmp	.+816    	; 0x738 <__LOCK_REGION_LENGTH__+0x338>
                    setup();
                    has_setup = 1;
                }
                is_in_low_voltage = 0;
     408:	10 92 0f 01 	sts	0x010F, r1	; 0x80010f <is_in_low_voltage>
                kilo_state = RUNNING;
     40c:	a0 92 13 01 	sts	0x0113, r10	; 0x800113 <kilo_state>
            case RUNNING:

                if(rx_busy){
     410:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <rx_busy>
     414:	dd 24       	eor	r13, r13
     416:	d3 94       	inc	r13
     418:	81 11       	cpse	r24, r1
     41a:	07 c0       	rjmp	.+14     	; 0x42a <__LOCK_REGION_LENGTH__+0x2a>
                }

                else if(is_in_low_voltage < N_REPETITIONS_LOW_VOLTAGE){

                    // Estimate voltage every 8 seconds, approximately
                    cli(); // Disable interrupts to read or write variable counter_ticks_for_voltage
     41c:	f8 94       	cli
                    if(counter_ticks_for_voltage == 255){
     41e:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <__data_end>
     422:	8f 3f       	cpi	r24, 0xFF	; 255
     424:	09 f4       	brne	.+2      	; 0x428 <__LOCK_REGION_LENGTH__+0x28>
     426:	d3 c1       	rjmp	.+934    	; 0x7ce <__LOCK_REGION_LENGTH__+0x3ce>
                            is_in_low_voltage = 0;
                            
                        }
                    }
                    else
                        sei(); // Enable interrupts
     428:	78 94       	sei

                    loop();
     42a:	f8 01       	movw	r30, r16
     42c:	09 95       	icall
     42e:	b4 cf       	rjmp	.-152    	; 0x398 <kilo_start+0x28>
    seed = s;
}

int16_t get_voltage() {
    int16_t voltage=-1;
    if (!rx_busy) {
     430:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <rx_busy>
     434:	81 11       	cpse	r24, r1
     436:	96 c1       	rjmp	.+812    	; 0x764 <__LOCK_REGION_LENGTH__+0x364>
        cli();                                    // disable interrupts
     438:	f8 94       	cli
        adc_setup_conversion(6);
     43a:	d0 93 7c 00 	sts	0x007C, r29	; 0x80007c <__DATA_REGION_ORIGIN__+0x1c>
     43e:	c0 93 7a 00 	sts	0x007A, r28	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
        adc_start_conversion();
     442:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
     446:	80 64       	ori	r24, 0x40	; 64
     448:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
        adc_finish_conversion();
     44c:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
     450:	86 fd       	sbrc	r24, 6
     452:	fc cf       	rjmp	.-8      	; 0x44c <__LOCK_REGION_LENGTH__+0x4c>
        voltage = ADCW;                           // store AD result
     454:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__DATA_REGION_ORIGIN__+0x18>
     458:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__DATA_REGION_ORIGIN__+0x19>
        
        //adc_trigger_high_gain();                     // set AD to measure high gain (for distance sensing)
            
        sei();                                    // reenable interrupts
     45c:	78 94       	sei
                    kilo_state = SLEEPING;
                }

                break;
            case BATTERY:
                voltage = get_voltage();
     45e:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <voltage+0x1>
     462:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <voltage>
                is_in_low_voltage = 0;
     466:	10 92 0f 01 	sts	0x010F, r1	; 0x80010f <is_in_low_voltage>

                if(voltage > 682)
     46a:	8b 3a       	cpi	r24, 0xAB	; 171
     46c:	22 e0       	ldi	r18, 0x02	; 2
     46e:	92 07       	cpc	r25, r18
     470:	0c f0       	brlt	.+2      	; 0x474 <__LOCK_REGION_LENGTH__+0x74>
     472:	3f c1       	rjmp	.+638    	; 0x6f2 <__LOCK_REGION_LENGTH__+0x2f2>
                    set_color(RGB(0,3,0));
                else if(voltage > 648)
     474:	89 38       	cpi	r24, 0x89	; 137
     476:	e2 e0       	ldi	r30, 0x02	; 2
     478:	9e 07       	cpc	r25, r30
     47a:	0c f0       	brlt	.+2      	; 0x47e <__LOCK_REGION_LENGTH__+0x7e>
     47c:	8e c1       	rjmp	.+796    	; 0x79a <__LOCK_REGION_LENGTH__+0x39a>
                    set_color(RGB(0,0,3));
                else if(voltage > 614)
     47e:	87 36       	cpi	r24, 0x67	; 103
     480:	92 40       	sbci	r25, 0x02	; 2
     482:	0c f4       	brge	.+2      	; 0x486 <__LOCK_REGION_LENGTH__+0x86>
     484:	75 c1       	rjmp	.+746    	; 0x770 <__LOCK_REGION_LENGTH__+0x370>

#endif

void set_color(uint8_t rgb) {
    if (rgb&(1<<0))
        DDRD |= (1<<5);
     486:	55 9a       	sbi	0x0a, 5	; 10
    else
        DDRD &= ~(1<<5);

    if (rgb&(1<<1))
        DDRD |= (1<<4);
     488:	54 9a       	sbi	0x0a, 4	; 10
    else
        DDRD &= ~(1<<4);

    if (rgb&(1<<2))
        DDRC |= (1<<3);
     48a:	3b 9a       	sbi	0x07, 3	; 7
    else
        DDRC &= ~(1<<3);

    if (rgb&(1<<3))
        DDRC |= (1<<2);
     48c:	3a 9a       	sbi	0x07, 2	; 7
        DDRC &= ~(1<<2);

    if (rgb&(1<<4))
        DDRC |= (1<<5);
    else
        DDRC &= ~(1<<5);
     48e:	3d 98       	cbi	0x07, 5	; 7

    if (rgb&(1<<5))
        DDRC |= (1<<4);
    else
        DDRC &= ~(1<<4);
     490:	3c 98       	cbi	0x07, 4	; 7
     492:	82 cf       	rjmp	.-252    	; 0x398 <kilo_start+0x28>
                }

                break;
            case IDLE:

                if(rx_busy){
     494:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <rx_busy>
     498:	81 11       	cpse	r24, r1
     49a:	32 c1       	rjmp	.+612    	; 0x700 <__LOCK_REGION_LENGTH__+0x300>
                    set_color(RGB(0,0,0));
                    _delay_ms(200);

                }

                else if(is_in_low_voltage < N_REPETITIONS_LOW_VOLTAGE){
     49c:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <is_in_low_voltage>
     4a0:	85 30       	cpi	r24, 0x05	; 5
     4a2:	08 f0       	brcs	.+2      	; 0x4a6 <__LOCK_REGION_LENGTH__+0xa6>
     4a4:	ab cf       	rjmp	.-170    	; 0x3fc <kilo_start+0x8c>
     4a6:	9a e0       	ldi	r25, 0x0A	; 10
     4a8:	2f ef       	ldi	r18, 0xFF	; 255
     4aa:	3f ef       	ldi	r19, 0xFF	; 255
    seed = s;
}

int16_t get_voltage() {
    int16_t voltage=-1;
    if (!rx_busy) {
     4ac:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <rx_busy>
     4b0:	81 11       	cpse	r24, r1
     4b2:	e9 c1       	rjmp	.+978    	; 0x886 <__LOCK_REGION_LENGTH__+0x486>
        cli();                                    // disable interrupts
     4b4:	f8 94       	cli
        adc_setup_conversion(6);
     4b6:	d0 93 7c 00 	sts	0x007C, r29	; 0x80007c <__DATA_REGION_ORIGIN__+0x1c>
     4ba:	c0 93 7a 00 	sts	0x007A, r28	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
        adc_start_conversion();
     4be:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
     4c2:	80 64       	ori	r24, 0x40	; 64
     4c4:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
        adc_finish_conversion();
     4c8:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
     4cc:	86 fd       	sbrc	r24, 6
     4ce:	fc cf       	rjmp	.-8      	; 0x4c8 <__LOCK_REGION_LENGTH__+0xc8>
        voltage = ADCW;                           // store AD result
     4d0:	40 91 78 00 	lds	r20, 0x0078	; 0x800078 <__DATA_REGION_ORIGIN__+0x18>
     4d4:	50 91 79 00 	lds	r21, 0x0079	; 0x800079 <__DATA_REGION_ORIGIN__+0x19>
        
        //adc_trigger_high_gain();                     // set AD to measure high gain (for distance sensing)
            
        sei();                                    // reenable interrupts
     4d8:	78 94       	sei

    for(i = 0; i < N_READINGS_VOLTAGE; i++){

        voltage = get_voltage();
    
        if(voltage <= HIGH_VOLTAGE_THRESHOLD && voltage > estimated_voltage){
     4da:	4d 3c       	cpi	r20, 0xCD	; 205
     4dc:	e2 e0       	ldi	r30, 0x02	; 2
     4de:	5e 07       	cpc	r21, r30
     4e0:	24 f4       	brge	.+8      	; 0x4ea <__LOCK_REGION_LENGTH__+0xea>
     4e2:	24 17       	cp	r18, r20
     4e4:	35 07       	cpc	r19, r21
     4e6:	0c f4       	brge	.+2      	; 0x4ea <__LOCK_REGION_LENGTH__+0xea>
     4e8:	9a 01       	movw	r18, r20
     4ea:	91 50       	subi	r25, 0x01	; 1

    uint8_t i;
    int16_t voltage;
    int16_t estimated_voltage = -1;

    for(i = 0; i < N_READINGS_VOLTAGE; i++){
     4ec:	f9 f6       	brne	.-66     	; 0x4ac <__LOCK_REGION_LENGTH__+0xac>

                }

                else if(is_in_low_voltage < N_REPETITIONS_LOW_VOLTAGE){

                    voltage = estimate_voltage(0);
     4ee:	30 93 02 01 	sts	0x0102, r19	; 0x800102 <voltage+0x1>
     4f2:	20 93 01 01 	sts	0x0101, r18	; 0x800101 <voltage>

                    if(voltage != -1 && voltage < LOW_VOLTAGE_THRESHOLD){
     4f6:	2f 3f       	cpi	r18, 0xFF	; 255
     4f8:	ff ef       	ldi	r31, 0xFF	; 255
     4fa:	3f 07       	cpc	r19, r31
     4fc:	09 f4       	brne	.+2      	; 0x500 <__LOCK_REGION_LENGTH__+0x100>
     4fe:	c6 c1       	rjmp	.+908    	; 0x88c <__LOCK_REGION_LENGTH__+0x48c>
     500:	23 32       	cpi	r18, 0x23	; 35
     502:	82 e0       	ldi	r24, 0x02	; 2
     504:	38 07       	cpc	r19, r24
     506:	0c f0       	brlt	.+2      	; 0x50a <__LOCK_REGION_LENGTH__+0x10a>
     508:	a3 c1       	rjmp	.+838    	; 0x850 <__LOCK_REGION_LENGTH__+0x450>

                        is_in_low_voltage++;
     50a:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <is_in_low_voltage>
     50e:	8f 5f       	subi	r24, 0xFF	; 255
     510:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <is_in_low_voltage>
                        
                    }

                    if(voltage > 682)
                        set_color(RGB(0,3,0));
                    else if(voltage > 648)
     514:	29 38       	cpi	r18, 0x89	; 137
     516:	e2 e0       	ldi	r30, 0x02	; 2
     518:	3e 07       	cpc	r19, r30
     51a:	0c f0       	brlt	.+2      	; 0x51e <__LOCK_REGION_LENGTH__+0x11e>
     51c:	c1 c1       	rjmp	.+898    	; 0x8a0 <__LOCK_REGION_LENGTH__+0x4a0>

#endif

void set_color(uint8_t rgb) {
    if (rgb&(1<<0))
        DDRD |= (1<<5);
     51e:	55 9a       	sbi	0x0a, 5	; 10
    else
        DDRD &= ~(1<<5);

    if (rgb&(1<<1))
        DDRD |= (1<<4);
     520:	54 9a       	sbi	0x0a, 4	; 10

                    if(voltage > 682)
                        set_color(RGB(0,3,0));
                    else if(voltage > 648)
                        set_color(RGB(0,0,3));
                    else if(voltage > 614)
     522:	27 36       	cpi	r18, 0x67	; 103
     524:	32 40       	sbci	r19, 0x02	; 2
     526:	0c f4       	brge	.+2      	; 0x52a <__LOCK_REGION_LENGTH__+0x12a>
     528:	47 cf       	rjmp	.-370    	; 0x3b8 <kilo_start+0x48>
        DDRD |= (1<<4);
    else
        DDRD &= ~(1<<4);

    if (rgb&(1<<2))
        DDRC |= (1<<3);
     52a:	3b 9a       	sbi	0x07, 3	; 7
    else
        DDRC &= ~(1<<3);

    if (rgb&(1<<3))
        DDRC |= (1<<2);
     52c:	3a 9a       	sbi	0x07, 2	; 7
        DDRC &= ~(1<<2);

    if (rgb&(1<<4))
        DDRC |= (1<<5);
    else
        DDRC &= ~(1<<5);
     52e:	3d 98       	cbi	0x07, 5	; 7

    if (rgb&(1<<5))
        DDRC |= (1<<4);
    else
        DDRC &= ~(1<<4);
     530:	3c 98       	cbi	0x07, 4	; 7
     532:	46 cf       	rjmp	.-372    	; 0x3c0 <kilo_start+0x50>
    while (1) {

        switch(kilo_state) {
            case SLEEPING:

                cli();
     534:	f8 94       	cli
                acomp_off();
     536:	80 b7       	in	r24, 0x30	; 48
     538:	87 7f       	andi	r24, 0xF7	; 247
     53a:	80 bf       	out	0x30, r24	; 48
                adc_off();
     53c:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
     540:	8f 77       	andi	r24, 0x7F	; 127
     542:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
                ports_off();
     546:	14 b8       	out	0x04, r1	; 4
     548:	17 b8       	out	0x07, r1	; 7
     54a:	1a b8       	out	0x0a, r1	; 10
     54c:	15 b8       	out	0x05, r1	; 5
     54e:	18 b8       	out	0x08, r1	; 8
     550:	1b b8       	out	0x0b, r1	; 11
     552:	0f b6       	in	r0, 0x3f	; 63
     554:	f8 94       	cli
     556:	a8 95       	wdr
     558:	b0 92 60 00 	sts	0x0060, r11	; 0x800060 <__DATA_REGION_ORIGIN__>
     55c:	0f be       	out	0x3f, r0	; 63
     55e:	c0 92 60 00 	sts	0x0060, r12	; 0x800060 <__DATA_REGION_ORIGIN__>
                wdt_enable(WDTO_8S);
                WDTCSR |= (1<<WDIE);
     562:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     566:	80 64       	ori	r24, 0x40	; 64
     568:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
                set_sleep_mode(SLEEP_MODE_PWR_DOWN);
     56c:	83 b7       	in	r24, 0x33	; 51
     56e:	81 7f       	andi	r24, 0xF1	; 241
     570:	84 60       	ori	r24, 0x04	; 4
     572:	83 bf       	out	0x33, r24	; 51
                cli();
     574:	f8 94       	cli
                sleep_enable();
     576:	83 b7       	in	r24, 0x33	; 51
     578:	81 60       	ori	r24, 0x01	; 1
     57a:	83 bf       	out	0x33, r24	; 51
                sei();
     57c:	78 94       	sei
                sleep_cpu();
     57e:	88 95       	sleep
                sleep_disable();
     580:	83 b7       	in	r24, 0x33	; 51
     582:	8e 7f       	andi	r24, 0xFE	; 254
     584:	83 bf       	out	0x33, r24	; 51
                sei();
     586:	78 94       	sei
                rx_busy = 0;
     588:	10 92 3b 01 	sts	0x013B, r1	; 0x80013b <rx_busy>
                ports_on();
     58c:	52 9a       	sbi	0x0a, 2	; 10
     58e:	5a 9a       	sbi	0x0b, 2	; 11
                adc_on();
     590:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
     594:	80 68       	ori	r24, 0x80	; 128
     596:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     59a:	87 e5       	ldi	r24, 0x57	; 87
     59c:	92 e0       	ldi	r25, 0x02	; 2
     59e:	01 97       	sbiw	r24, 0x01	; 1
     5a0:	f1 f7       	brne	.-4      	; 0x59e <__LOCK_REGION_LENGTH__+0x19e>
     5a2:	00 c0       	rjmp	.+0      	; 0x5a4 <__LOCK_REGION_LENGTH__+0x1a4>
     5a4:	00 00       	nop
                _delay_us(300);
                acomp_on();
     5a6:	80 b7       	in	r24, 0x30	; 48
     5a8:	88 61       	ori	r24, 0x18	; 24
     5aa:	80 bf       	out	0x30, r24	; 48

                if(is_in_low_voltage == N_REPETITIONS_LOW_VOLTAGE){ // Low battery
     5ac:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <is_in_low_voltage>
     5b0:	85 30       	cpi	r24, 0x05	; 5
     5b2:	09 f4       	brne	.+2      	; 0x5b6 <__LOCK_REGION_LENGTH__+0x1b6>
     5b4:	c7 c0       	rjmp	.+398    	; 0x744 <__LOCK_REGION_LENGTH__+0x344>
     5b6:	9a e0       	ldi	r25, 0x0A	; 10
     5b8:	2f ef       	ldi	r18, 0xFF	; 255
     5ba:	3f ef       	ldi	r19, 0xFF	; 255
    seed = s;
}

int16_t get_voltage() {
    int16_t voltage=-1;
    if (!rx_busy) {
     5bc:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <rx_busy>
     5c0:	81 11       	cpse	r24, r1
     5c2:	bd c0       	rjmp	.+378    	; 0x73e <__LOCK_REGION_LENGTH__+0x33e>
        cli();                                    // disable interrupts
     5c4:	f8 94       	cli
        adc_setup_conversion(6);
     5c6:	d0 93 7c 00 	sts	0x007C, r29	; 0x80007c <__DATA_REGION_ORIGIN__+0x1c>
     5ca:	c0 93 7a 00 	sts	0x007A, r28	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
        adc_start_conversion();
     5ce:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
     5d2:	80 64       	ori	r24, 0x40	; 64
     5d4:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
        adc_finish_conversion();
     5d8:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
     5dc:	86 fd       	sbrc	r24, 6
     5de:	fc cf       	rjmp	.-8      	; 0x5d8 <__LOCK_REGION_LENGTH__+0x1d8>
        voltage = ADCW;                           // store AD result
     5e0:	40 91 78 00 	lds	r20, 0x0078	; 0x800078 <__DATA_REGION_ORIGIN__+0x18>
     5e4:	50 91 79 00 	lds	r21, 0x0079	; 0x800079 <__DATA_REGION_ORIGIN__+0x19>
        
        //adc_trigger_high_gain();                     // set AD to measure high gain (for distance sensing)
            
        sei();                                    // reenable interrupts
     5e8:	78 94       	sei

    for(i = 0; i < N_READINGS_VOLTAGE; i++){

        voltage = get_voltage();
    
        if(voltage <= HIGH_VOLTAGE_THRESHOLD && voltage > estimated_voltage){
     5ea:	4d 3c       	cpi	r20, 0xCD	; 205
     5ec:	82 e0       	ldi	r24, 0x02	; 2
     5ee:	58 07       	cpc	r21, r24
     5f0:	24 f4       	brge	.+8      	; 0x5fa <__LOCK_REGION_LENGTH__+0x1fa>
     5f2:	24 17       	cp	r18, r20
     5f4:	35 07       	cpc	r19, r21
     5f6:	0c f4       	brge	.+2      	; 0x5fa <__LOCK_REGION_LENGTH__+0x1fa>
     5f8:	9a 01       	movw	r18, r20
     5fa:	91 50       	subi	r25, 0x01	; 1

    uint8_t i;
    int16_t voltage;
    int16_t estimated_voltage = -1;

    for(i = 0; i < N_READINGS_VOLTAGE; i++){
     5fc:	f9 f6       	brne	.-66     	; 0x5bc <__LOCK_REGION_LENGTH__+0x1bc>
                    set_color(RGB(0,0,0));
    
                }
                else{

                    voltage = estimate_voltage(0);
     5fe:	30 93 02 01 	sts	0x0102, r19	; 0x800102 <voltage+0x1>
     602:	20 93 01 01 	sts	0x0101, r18	; 0x800101 <voltage>

                    if(voltage != -1 && voltage < LOW_VOLTAGE_THRESHOLD){
     606:	2f 3f       	cpi	r18, 0xFF	; 255
     608:	9f ef       	ldi	r25, 0xFF	; 255
     60a:	39 07       	cpc	r19, r25
     60c:	09 f4       	brne	.+2      	; 0x610 <__LOCK_REGION_LENGTH__+0x210>
     60e:	cc c0       	rjmp	.+408    	; 0x7a8 <__LOCK_REGION_LENGTH__+0x3a8>
     610:	23 32       	cpi	r18, 0x23	; 35
     612:	e2 e0       	ldi	r30, 0x02	; 2
     614:	3e 07       	cpc	r19, r30
     616:	0c f0       	brlt	.+2      	; 0x61a <__LOCK_REGION_LENGTH__+0x21a>
     618:	5e c0       	rjmp	.+188    	; 0x6d6 <__LOCK_REGION_LENGTH__+0x2d6>

                        is_in_low_voltage++;
     61a:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <is_in_low_voltage>
     61e:	8f 5f       	subi	r24, 0xFF	; 255
     620:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <is_in_low_voltage>
                        
                    }

                    if(voltage > 682)
                        set_color(RGB(0,3,0));
                    else if(voltage > 648)
     624:	29 38       	cpi	r18, 0x89	; 137
     626:	82 e0       	ldi	r24, 0x02	; 2
     628:	38 07       	cpc	r19, r24
     62a:	0c f0       	brlt	.+2      	; 0x62e <__LOCK_REGION_LENGTH__+0x22e>
     62c:	c4 c0       	rjmp	.+392    	; 0x7b6 <__LOCK_REGION_LENGTH__+0x3b6>

#endif

void set_color(uint8_t rgb) {
    if (rgb&(1<<0))
        DDRD |= (1<<5);
     62e:	55 9a       	sbi	0x0a, 5	; 10
    else
        DDRD &= ~(1<<5);

    if (rgb&(1<<1))
        DDRD |= (1<<4);
     630:	54 9a       	sbi	0x0a, 4	; 10

                    if(voltage > 682)
                        set_color(RGB(0,3,0));
                    else if(voltage > 648)
                        set_color(RGB(0,0,3));
                    else if(voltage > 614)
     632:	27 36       	cpi	r18, 0x67	; 103
     634:	32 40       	sbci	r19, 0x02	; 2
     636:	0c f0       	brlt	.+2      	; 0x63a <__LOCK_REGION_LENGTH__+0x23a>
     638:	c5 c0       	rjmp	.+394    	; 0x7c4 <__LOCK_REGION_LENGTH__+0x3c4>
        DDRD &= ~(1<<4);

    if (rgb&(1<<2))
        DDRC |= (1<<3);
    else
        DDRC &= ~(1<<3);
     63a:	3b 98       	cbi	0x07, 3	; 7

    if (rgb&(1<<3))
        DDRC |= (1<<2);
    else
        DDRC &= ~(1<<2);
     63c:	3a 98       	cbi	0x07, 2	; 7

    if (rgb&(1<<4))
        DDRC |= (1<<5);
    else
        DDRC &= ~(1<<5);
     63e:	3d 98       	cbi	0x07, 5	; 7

    if (rgb&(1<<5))
        DDRC |= (1<<4);
    else
        DDRC &= ~(1<<4);
     640:	3c 98       	cbi	0x07, 4	; 7
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     642:	ef e1       	ldi	r30, 0x1F	; 31
     644:	fe e4       	ldi	r31, 0x4E	; 78
     646:	31 97       	sbiw	r30, 0x01	; 1
     648:	f1 f7       	brne	.-4      	; 0x646 <__LOCK_REGION_LENGTH__+0x246>
     64a:	00 c0       	rjmp	.+0      	; 0x64c <__LOCK_REGION_LENGTH__+0x24c>
     64c:	00 00       	nop
                        set_color(RGB(3,0,0));
                    else
                        set_color(RGB(3,3,3));

                    _delay_ms(10);
                    if (rx_busy) {
     64e:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <rx_busy>
     652:	81 11       	cpse	r24, r1
     654:	94 c0       	rjmp	.+296    	; 0x77e <__LOCK_REGION_LENGTH__+0x37e>

void set_color(uint8_t rgb) {
    if (rgb&(1<<0))
        DDRD |= (1<<5);
    else
        DDRD &= ~(1<<5);
     656:	55 98       	cbi	0x0a, 5	; 10

    if (rgb&(1<<1))
        DDRD |= (1<<4);
    else
        DDRD &= ~(1<<4);
     658:	54 98       	cbi	0x0a, 4	; 10

    if (rgb&(1<<2))
        DDRC |= (1<<3);
    else
        DDRC &= ~(1<<3);
     65a:	3b 98       	cbi	0x07, 3	; 7

    if (rgb&(1<<3))
        DDRC |= (1<<2);
    else
        DDRC &= ~(1<<2);
     65c:	3a 98       	cbi	0x07, 2	; 7

    if (rgb&(1<<4))
        DDRC |= (1<<5);
    else
        DDRC &= ~(1<<5);
     65e:	3d 98       	cbi	0x07, 5	; 7

    if (rgb&(1<<5))
        DDRC |= (1<<4);
    else
        DDRC &= ~(1<<4);
     660:	3c 98       	cbi	0x07, 4	; 7
     662:	9a ce       	rjmp	.-716    	; 0x398 <kilo_start+0x28>
                }


                break;
            case MOVING:
                is_in_low_voltage = 0;
     664:	10 92 0f 01 	sts	0x010F, r1	; 0x80010f <is_in_low_voltage>
                if (cur_motion == MOVE_STOP) {
     668:	80 91 11 01 	lds	r24, 0x0111	; 0x800111 <cur_motion>
     66c:	81 11       	cpse	r24, r1
     66e:	07 c0       	rjmp	.+14     	; 0x67e <__LOCK_REGION_LENGTH__+0x27e>
        ms--;
    }
}

void set_motors(uint8_t ccw, uint8_t cw) {
    OCR2A = ccw;
     670:	10 92 b3 00 	sts	0x00B3, r1	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
    OCR2B = cw;
     674:	10 92 b4 00 	sts	0x00B4, r1	; 0x8000b4 <__DATA_REGION_ORIGIN__+0x54>
                break;
            case MOVING:
                is_in_low_voltage = 0;
                if (cur_motion == MOVE_STOP) {
                    set_motors(0,0);
                    prev_motion = MOVE_STOP;
     678:	10 92 12 01 	sts	0x0112, r1	; 0x800112 <prev_motion>
     67c:	8d ce       	rjmp	.-742    	; 0x398 <kilo_start+0x28>
                } else {
                    if (cur_motion != prev_motion) {
     67e:	90 91 11 01 	lds	r25, 0x0111	; 0x800111 <cur_motion>
     682:	80 91 12 01 	lds	r24, 0x0112	; 0x800112 <prev_motion>
     686:	98 17       	cp	r25, r24
     688:	09 f4       	brne	.+2      	; 0x68c <__LOCK_REGION_LENGTH__+0x28c>
     68a:	86 ce       	rjmp	.-756    	; 0x398 <kilo_start+0x28>
                        prev_motion = cur_motion;
     68c:	80 91 11 01 	lds	r24, 0x0111	; 0x800111 <cur_motion>
     690:	80 93 12 01 	sts	0x0112, r24	; 0x800112 <prev_motion>
                        if (cur_motion == MOVE_LEFT) {
     694:	80 91 11 01 	lds	r24, 0x0111	; 0x800111 <cur_motion>
     698:	81 30       	cpi	r24, 0x01	; 1
     69a:	09 f4       	brne	.+2      	; 0x69e <__LOCK_REGION_LENGTH__+0x29e>
     69c:	08 c1       	rjmp	.+528    	; 0x8ae <__LOCK_REGION_LENGTH__+0x4ae>
                            set_motors(0xFF, 0);
                            _delay_ms(15);
                            set_motors(kilo_turn_left, 0);
                        } else if (cur_motion == MOVE_RIGHT) {
     69e:	80 91 11 01 	lds	r24, 0x0111	; 0x800111 <cur_motion>
        ms--;
    }
}

void set_motors(uint8_t ccw, uint8_t cw) {
    OCR2A = ccw;
     6a2:	10 92 b3 00 	sts	0x00B3, r1	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
    OCR2B = cw;
     6a6:	90 92 b4 00 	sts	0x00B4, r9	; 0x8000b4 <__DATA_REGION_ORIGIN__+0x54>
                        prev_motion = cur_motion;
                        if (cur_motion == MOVE_LEFT) {
                            set_motors(0xFF, 0);
                            _delay_ms(15);
                            set_motors(kilo_turn_left, 0);
                        } else if (cur_motion == MOVE_RIGHT) {
     6aa:	82 30       	cpi	r24, 0x02	; 2
     6ac:	09 f4       	brne	.+2      	; 0x6b0 <__LOCK_REGION_LENGTH__+0x2b0>
     6ae:	de c0       	rjmp	.+444    	; 0x86c <__LOCK_REGION_LENGTH__+0x46c>
        ms--;
    }
}

void set_motors(uint8_t ccw, uint8_t cw) {
    OCR2A = ccw;
     6b0:	90 92 b3 00 	sts	0x00B3, r9	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
    OCR2B = cw;
     6b4:	90 92 b4 00 	sts	0x00B4, r9	; 0x8000b4 <__DATA_REGION_ORIGIN__+0x54>
     6b8:	8f e2       	ldi	r24, 0x2F	; 47
     6ba:	95 e7       	ldi	r25, 0x75	; 117
     6bc:	01 97       	sbiw	r24, 0x01	; 1
     6be:	f1 f7       	brne	.-4      	; 0x6bc <__LOCK_REGION_LENGTH__+0x2bc>
     6c0:	00 c0       	rjmp	.+0      	; 0x6c2 <__LOCK_REGION_LENGTH__+0x2c2>
     6c2:	00 00       	nop
                            set_motors(0, kilo_turn_right);
                        } else {
                            set_motors(0, 0xFF);
                            set_motors(0xFF, 0xFF);
                            _delay_ms(15);
                            set_motors(kilo_straight_left, kilo_straight_right);
     6c4:	80 91 71 01 	lds	r24, 0x0171	; 0x800171 <kilo_straight_right>
     6c8:	90 91 70 01 	lds	r25, 0x0170	; 0x800170 <kilo_straight_left>
        ms--;
    }
}

void set_motors(uint8_t ccw, uint8_t cw) {
    OCR2A = ccw;
     6cc:	90 93 b3 00 	sts	0x00B3, r25	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
    OCR2B = cw;
     6d0:	80 93 b4 00 	sts	0x00B4, r24	; 0x8000b4 <__DATA_REGION_ORIGIN__+0x54>
     6d4:	61 ce       	rjmp	.-830    	; 0x398 <kilo_start+0x28>
                        is_in_low_voltage++;

                    }
                    else if(voltage != -1){

                        is_in_low_voltage = 0;
     6d6:	10 92 0f 01 	sts	0x010F, r1	; 0x80010f <is_in_low_voltage>
                        
                    }

                    if(voltage > 682)
     6da:	2b 3a       	cpi	r18, 0xAB	; 171
     6dc:	f2 e0       	ldi	r31, 0x02	; 2
     6de:	3f 07       	cpc	r19, r31
     6e0:	0c f4       	brge	.+2      	; 0x6e4 <__LOCK_REGION_LENGTH__+0x2e4>
     6e2:	a0 cf       	rjmp	.-192    	; 0x624 <__LOCK_REGION_LENGTH__+0x224>

void set_color(uint8_t rgb) {
    if (rgb&(1<<0))
        DDRD |= (1<<5);
    else
        DDRD &= ~(1<<5);
     6e4:	55 98       	cbi	0x0a, 5	; 10

    if (rgb&(1<<1))
        DDRD |= (1<<4);
    else
        DDRD &= ~(1<<4);
     6e6:	54 98       	cbi	0x0a, 4	; 10

    if (rgb&(1<<2))
        DDRC |= (1<<3);
     6e8:	3b 9a       	sbi	0x07, 3	; 7
    else
        DDRC &= ~(1<<3);

    if (rgb&(1<<3))
        DDRC |= (1<<2);
     6ea:	3a 9a       	sbi	0x07, 2	; 7
        DDRC &= ~(1<<2);

    if (rgb&(1<<4))
        DDRC |= (1<<5);
    else
        DDRC &= ~(1<<5);
     6ec:	3d 98       	cbi	0x07, 5	; 7

    if (rgb&(1<<5))
        DDRC |= (1<<4);
    else
        DDRC &= ~(1<<4);
     6ee:	3c 98       	cbi	0x07, 4	; 7
     6f0:	a8 cf       	rjmp	.-176    	; 0x642 <__LOCK_REGION_LENGTH__+0x242>

void set_color(uint8_t rgb) {
    if (rgb&(1<<0))
        DDRD |= (1<<5);
    else
        DDRD &= ~(1<<5);
     6f2:	55 98       	cbi	0x0a, 5	; 10

    if (rgb&(1<<1))
        DDRD |= (1<<4);
    else
        DDRD &= ~(1<<4);
     6f4:	54 98       	cbi	0x0a, 4	; 10

    if (rgb&(1<<2))
        DDRC |= (1<<3);
     6f6:	3b 9a       	sbi	0x07, 3	; 7
    else
        DDRC &= ~(1<<3);

    if (rgb&(1<<3))
        DDRC |= (1<<2);
     6f8:	3a 9a       	sbi	0x07, 2	; 7
        DDRC &= ~(1<<2);

    if (rgb&(1<<4))
        DDRC |= (1<<5);
    else
        DDRC &= ~(1<<5);
     6fa:	3d 98       	cbi	0x07, 5	; 7

    if (rgb&(1<<5))
        DDRC |= (1<<4);
    else
        DDRC &= ~(1<<4);
     6fc:	3c 98       	cbi	0x07, 4	; 7
     6fe:	4c ce       	rjmp	.-872    	; 0x398 <kilo_start+0x28>

void set_color(uint8_t rgb) {
    if (rgb&(1<<0))
        DDRD |= (1<<5);
    else
        DDRD &= ~(1<<5);
     700:	55 98       	cbi	0x0a, 5	; 10

    if (rgb&(1<<1))
        DDRD |= (1<<4);
    else
        DDRD &= ~(1<<4);
     702:	54 98       	cbi	0x0a, 4	; 10

    if (rgb&(1<<2))
        DDRC |= (1<<3);
     704:	3b 9a       	sbi	0x07, 3	; 7
    else
        DDRC &= ~(1<<3);

    if (rgb&(1<<3))
        DDRC |= (1<<2);
     706:	3a 9a       	sbi	0x07, 2	; 7
        DDRC &= ~(1<<2);

    if (rgb&(1<<4))
        DDRC |= (1<<5);
    else
        DDRC &= ~(1<<5);
     708:	3d 98       	cbi	0x07, 5	; 7

    if (rgb&(1<<5))
        DDRC |= (1<<4);
    else
        DDRC &= ~(1<<4);
     70a:	3c 98       	cbi	0x07, 4	; 7
     70c:	ef ec       	ldi	r30, 0xCF	; 207
     70e:	f7 e0       	ldi	r31, 0x07	; 7
     710:	31 97       	sbiw	r30, 0x01	; 1
     712:	f1 f7       	brne	.-4      	; 0x710 <__LOCK_REGION_LENGTH__+0x310>
     714:	00 c0       	rjmp	.+0      	; 0x716 <__LOCK_REGION_LENGTH__+0x316>
     716:	00 00       	nop

void set_color(uint8_t rgb) {
    if (rgb&(1<<0))
        DDRD |= (1<<5);
    else
        DDRD &= ~(1<<5);
     718:	55 98       	cbi	0x0a, 5	; 10

    if (rgb&(1<<1))
        DDRD |= (1<<4);
    else
        DDRD &= ~(1<<4);
     71a:	54 98       	cbi	0x0a, 4	; 10

    if (rgb&(1<<2))
        DDRC |= (1<<3);
    else
        DDRC &= ~(1<<3);
     71c:	3b 98       	cbi	0x07, 3	; 7

    if (rgb&(1<<3))
        DDRC |= (1<<2);
    else
        DDRC &= ~(1<<2);
     71e:	3a 98       	cbi	0x07, 2	; 7

    if (rgb&(1<<4))
        DDRC |= (1<<5);
    else
        DDRC &= ~(1<<5);
     720:	3d 98       	cbi	0x07, 5	; 7

    if (rgb&(1<<5))
        DDRC |= (1<<4);
    else
        DDRC &= ~(1<<4);
     722:	3c 98       	cbi	0x07, 4	; 7
     724:	ff ef       	ldi	r31, 0xFF	; 255
     726:	21 ee       	ldi	r18, 0xE1	; 225
     728:	84 e0       	ldi	r24, 0x04	; 4
     72a:	f1 50       	subi	r31, 0x01	; 1
     72c:	20 40       	sbci	r18, 0x00	; 0
     72e:	80 40       	sbci	r24, 0x00	; 0
     730:	e1 f7       	brne	.-8      	; 0x72a <__LOCK_REGION_LENGTH__+0x32a>
     732:	00 c0       	rjmp	.+0      	; 0x734 <__LOCK_REGION_LENGTH__+0x334>
     734:	00 00       	nop
     736:	30 ce       	rjmp	.-928    	; 0x398 <kilo_start+0x28>
                    set_color(RGB(0,0,0));

                break;
            case SETUP:
                if (!has_setup) {
                    setup();
     738:	f7 01       	movw	r30, r14
     73a:	09 95       	icall
     73c:	65 ce       	rjmp	.-822    	; 0x408 <__LOCK_REGION_LENGTH__+0x8>
void rand_seed(uint8_t s) {
    seed = s;
}

int16_t get_voltage() {
    int16_t voltage=-1;
     73e:	4f ef       	ldi	r20, 0xFF	; 255
     740:	5f ef       	ldi	r21, 0xFF	; 255
     742:	57 cf       	rjmp	.-338    	; 0x5f2 <__LOCK_REGION_LENGTH__+0x1f2>

#endif

void set_color(uint8_t rgb) {
    if (rgb&(1<<0))
        DDRD |= (1<<5);
     744:	55 9a       	sbi	0x0a, 5	; 10
    else
        DDRD &= ~(1<<5);

    if (rgb&(1<<1))
        DDRD |= (1<<4);
     746:	54 9a       	sbi	0x0a, 4	; 10
        DDRD &= ~(1<<4);

    if (rgb&(1<<2))
        DDRC |= (1<<3);
    else
        DDRC &= ~(1<<3);
     748:	3b 98       	cbi	0x07, 3	; 7

    if (rgb&(1<<3))
        DDRC |= (1<<2);
    else
        DDRC &= ~(1<<2);
     74a:	3a 98       	cbi	0x07, 2	; 7

    if (rgb&(1<<4))
        DDRC |= (1<<5);
    else
        DDRC &= ~(1<<5);
     74c:	3d 98       	cbi	0x07, 5	; 7

    if (rgb&(1<<5))
        DDRC |= (1<<4);
    else
        DDRC &= ~(1<<4);
     74e:	3c 98       	cbi	0x07, 4	; 7
     750:	9f ef       	ldi	r25, 0xFF	; 255
     752:	e9 e6       	ldi	r30, 0x69	; 105
     754:	f8 e1       	ldi	r31, 0x18	; 24
     756:	91 50       	subi	r25, 0x01	; 1
     758:	e0 40       	sbci	r30, 0x00	; 0
     75a:	f0 40       	sbci	r31, 0x00	; 0
     75c:	e1 f7       	brne	.-8      	; 0x756 <__LOCK_REGION_LENGTH__+0x356>
     75e:	00 c0       	rjmp	.+0      	; 0x760 <__LOCK_REGION_LENGTH__+0x360>
     760:	00 00       	nop
     762:	79 cf       	rjmp	.-270    	; 0x656 <__LOCK_REGION_LENGTH__+0x256>
                    kilo_state = SLEEPING;
                }

                break;
            case BATTERY:
                voltage = get_voltage();
     764:	70 92 02 01 	sts	0x0102, r7	; 0x800102 <voltage+0x1>
     768:	60 92 01 01 	sts	0x0101, r6	; 0x800101 <voltage>
                is_in_low_voltage = 0;
     76c:	10 92 0f 01 	sts	0x010F, r1	; 0x80010f <is_in_low_voltage>

#endif

void set_color(uint8_t rgb) {
    if (rgb&(1<<0))
        DDRD |= (1<<5);
     770:	55 9a       	sbi	0x0a, 5	; 10
    else
        DDRD &= ~(1<<5);

    if (rgb&(1<<1))
        DDRD |= (1<<4);
     772:	54 9a       	sbi	0x0a, 4	; 10
        DDRD &= ~(1<<4);

    if (rgb&(1<<2))
        DDRC |= (1<<3);
    else
        DDRC &= ~(1<<3);
     774:	3b 98       	cbi	0x07, 3	; 7

    if (rgb&(1<<3))
        DDRC |= (1<<2);
    else
        DDRC &= ~(1<<2);
     776:	3a 98       	cbi	0x07, 2	; 7

    if (rgb&(1<<4))
        DDRC |= (1<<5);
    else
        DDRC &= ~(1<<5);
     778:	3d 98       	cbi	0x07, 5	; 7

    if (rgb&(1<<5))
        DDRC |= (1<<4);
    else
        DDRC &= ~(1<<4);
     77a:	3c 98       	cbi	0x07, 4	; 7
     77c:	0d ce       	rjmp	.-998    	; 0x398 <kilo_start+0x28>

void set_color(uint8_t rgb) {
    if (rgb&(1<<0))
        DDRD |= (1<<5);
    else
        DDRD &= ~(1<<5);
     77e:	55 98       	cbi	0x0a, 5	; 10

    if (rgb&(1<<1))
        DDRD |= (1<<4);
    else
        DDRD &= ~(1<<4);
     780:	54 98       	cbi	0x0a, 4	; 10

    if (rgb&(1<<2))
        DDRC |= (1<<3);
     782:	3b 9a       	sbi	0x07, 3	; 7
    else
        DDRC &= ~(1<<3);

    if (rgb&(1<<3))
        DDRC |= (1<<2);
     784:	3a 9a       	sbi	0x07, 2	; 7
        DDRC &= ~(1<<2);

    if (rgb&(1<<4))
        DDRC |= (1<<5);
    else
        DDRC &= ~(1<<5);
     786:	3d 98       	cbi	0x07, 5	; 7

    if (rgb&(1<<5))
        DDRC |= (1<<4);
    else
        DDRC &= ~(1<<4);
     788:	3c 98       	cbi	0x07, 4	; 7
     78a:	ff ef       	ldi	r31, 0xFF	; 255
     78c:	20 e7       	ldi	r18, 0x70	; 112
     78e:	82 e0       	ldi	r24, 0x02	; 2
     790:	f1 50       	subi	r31, 0x01	; 1
     792:	20 40       	sbci	r18, 0x00	; 0
     794:	80 40       	sbci	r24, 0x00	; 0
     796:	e1 f7       	brne	.-8      	; 0x790 <__LOCK_REGION_LENGTH__+0x390>
     798:	e2 cf       	rjmp	.-60     	; 0x75e <__LOCK_REGION_LENGTH__+0x35e>

void set_color(uint8_t rgb) {
    if (rgb&(1<<0))
        DDRD |= (1<<5);
    else
        DDRD &= ~(1<<5);
     79a:	55 98       	cbi	0x0a, 5	; 10

    if (rgb&(1<<1))
        DDRD |= (1<<4);
    else
        DDRD &= ~(1<<4);
     79c:	54 98       	cbi	0x0a, 4	; 10

    if (rgb&(1<<2))
        DDRC |= (1<<3);
    else
        DDRC &= ~(1<<3);
     79e:	3b 98       	cbi	0x07, 3	; 7

    if (rgb&(1<<3))
        DDRC |= (1<<2);
    else
        DDRC &= ~(1<<2);
     7a0:	3a 98       	cbi	0x07, 2	; 7

    if (rgb&(1<<4))
        DDRC |= (1<<5);
     7a2:	3d 9a       	sbi	0x07, 5	; 7
    else
        DDRC &= ~(1<<5);

    if (rgb&(1<<5))
        DDRC |= (1<<4);
     7a4:	3c 9a       	sbi	0x07, 4	; 7
     7a6:	f8 cd       	rjmp	.-1040   	; 0x398 <kilo_start+0x28>

#endif

void set_color(uint8_t rgb) {
    if (rgb&(1<<0))
        DDRD |= (1<<5);
     7a8:	55 9a       	sbi	0x0a, 5	; 10
    else
        DDRD &= ~(1<<5);

    if (rgb&(1<<1))
        DDRD |= (1<<4);
     7aa:	54 9a       	sbi	0x0a, 4	; 10
    else
        DDRD &= ~(1<<4);

    if (rgb&(1<<2))
        DDRC |= (1<<3);
     7ac:	3b 9a       	sbi	0x07, 3	; 7
    else
        DDRC &= ~(1<<3);

    if (rgb&(1<<3))
        DDRC |= (1<<2);
     7ae:	3a 9a       	sbi	0x07, 2	; 7
    else
        DDRC &= ~(1<<2);

    if (rgb&(1<<4))
        DDRC |= (1<<5);
     7b0:	3d 9a       	sbi	0x07, 5	; 7
    else
        DDRC &= ~(1<<5);

    if (rgb&(1<<5))
        DDRC |= (1<<4);
     7b2:	3c 9a       	sbi	0x07, 4	; 7
     7b4:	46 cf       	rjmp	.-372    	; 0x642 <__LOCK_REGION_LENGTH__+0x242>

void set_color(uint8_t rgb) {
    if (rgb&(1<<0))
        DDRD |= (1<<5);
    else
        DDRD &= ~(1<<5);
     7b6:	55 98       	cbi	0x0a, 5	; 10

    if (rgb&(1<<1))
        DDRD |= (1<<4);
    else
        DDRD &= ~(1<<4);
     7b8:	54 98       	cbi	0x0a, 4	; 10

    if (rgb&(1<<2))
        DDRC |= (1<<3);
    else
        DDRC &= ~(1<<3);
     7ba:	3b 98       	cbi	0x07, 3	; 7

    if (rgb&(1<<3))
        DDRC |= (1<<2);
    else
        DDRC &= ~(1<<2);
     7bc:	3a 98       	cbi	0x07, 2	; 7

    if (rgb&(1<<4))
        DDRC |= (1<<5);
     7be:	3d 9a       	sbi	0x07, 5	; 7
    else
        DDRC &= ~(1<<5);

    if (rgb&(1<<5))
        DDRC |= (1<<4);
     7c0:	3c 9a       	sbi	0x07, 4	; 7
     7c2:	3f cf       	rjmp	.-386    	; 0x642 <__LOCK_REGION_LENGTH__+0x242>
        DDRD |= (1<<4);
    else
        DDRD &= ~(1<<4);

    if (rgb&(1<<2))
        DDRC |= (1<<3);
     7c4:	3b 9a       	sbi	0x07, 3	; 7
    else
        DDRC &= ~(1<<3);

    if (rgb&(1<<3))
        DDRC |= (1<<2);
     7c6:	3a 9a       	sbi	0x07, 2	; 7
        DDRC &= ~(1<<2);

    if (rgb&(1<<4))
        DDRC |= (1<<5);
    else
        DDRC &= ~(1<<5);
     7c8:	3d 98       	cbi	0x07, 5	; 7

    if (rgb&(1<<5))
        DDRC |= (1<<4);
    else
        DDRC &= ~(1<<4);
     7ca:	3c 98       	cbi	0x07, 4	; 7
     7cc:	3a cf       	rjmp	.-396    	; 0x642 <__LOCK_REGION_LENGTH__+0x242>

                    // Estimate voltage every 8 seconds, approximately
                    cli(); // Disable interrupts to read or write variable counter_ticks_for_voltage
                    if(counter_ticks_for_voltage == 255){

                        counter_ticks_for_voltage = 0;
     7ce:	10 92 0e 01 	sts	0x010E, r1	; 0x80010e <__data_end>
                        sei(); // Enable interrupts
     7d2:	78 94       	sei
     7d4:	9a e0       	ldi	r25, 0x0A	; 10
 */
int16_t estimate_voltage(uint8_t trigger_high_gain){

    uint8_t i;
    int16_t voltage;
    int16_t estimated_voltage = -1;
     7d6:	2f ef       	ldi	r18, 0xFF	; 255
     7d8:	3f ef       	ldi	r19, 0xFF	; 255
    seed = s;
}

int16_t get_voltage() {
    int16_t voltage=-1;
    if (!rx_busy) {
     7da:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <rx_busy>
     7de:	81 11       	cpse	r24, r1
     7e0:	77 c0       	rjmp	.+238    	; 0x8d0 <__LOCK_REGION_LENGTH__+0x4d0>
        cli();                                    // disable interrupts
     7e2:	f8 94       	cli
        adc_setup_conversion(6);
     7e4:	d0 93 7c 00 	sts	0x007C, r29	; 0x80007c <__DATA_REGION_ORIGIN__+0x1c>
     7e8:	c0 93 7a 00 	sts	0x007A, r28	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
        adc_start_conversion();
     7ec:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
     7f0:	80 64       	ori	r24, 0x40	; 64
     7f2:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
        adc_finish_conversion();
     7f6:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
     7fa:	86 fd       	sbrc	r24, 6
     7fc:	fc cf       	rjmp	.-8      	; 0x7f6 <__LOCK_REGION_LENGTH__+0x3f6>
        voltage = ADCW;                           // store AD result
     7fe:	40 91 78 00 	lds	r20, 0x0078	; 0x800078 <__DATA_REGION_ORIGIN__+0x18>
     802:	50 91 79 00 	lds	r21, 0x0079	; 0x800079 <__DATA_REGION_ORIGIN__+0x19>
        
        //adc_trigger_high_gain();                     // set AD to measure high gain (for distance sensing)
            
        sei();                                    // reenable interrupts
     806:	78 94       	sei

    for(i = 0; i < N_READINGS_VOLTAGE; i++){

        voltage = get_voltage();
    
        if(voltage <= HIGH_VOLTAGE_THRESHOLD && voltage > estimated_voltage){
     808:	4d 3c       	cpi	r20, 0xCD	; 205
     80a:	f2 e0       	ldi	r31, 0x02	; 2
     80c:	5f 07       	cpc	r21, r31
     80e:	24 f4       	brge	.+8      	; 0x818 <__LOCK_REGION_LENGTH__+0x418>
     810:	24 17       	cp	r18, r20
     812:	35 07       	cpc	r19, r21
     814:	0c f4       	brge	.+2      	; 0x818 <__LOCK_REGION_LENGTH__+0x418>
     816:	9a 01       	movw	r18, r20
     818:	91 50       	subi	r25, 0x01	; 1

    uint8_t i;
    int16_t voltage;
    int16_t estimated_voltage = -1;

    for(i = 0; i < N_READINGS_VOLTAGE; i++){
     81a:	f9 f6       	brne	.-66     	; 0x7da <__LOCK_REGION_LENGTH__+0x3da>
          
        }
    }

    if(trigger_high_gain){
        cli();
     81c:	f8 94       	cli
        adc_trigger_high_gain();
     81e:	10 92 7c 00 	sts	0x007C, r1	; 0x80007c <__DATA_REGION_ORIGIN__+0x1c>
     822:	50 92 7a 00 	sts	0x007A, r5	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
     826:	80 92 7b 00 	sts	0x007B, r8	; 0x80007b <__DATA_REGION_ORIGIN__+0x1b>
        sei();
     82a:	78 94       	sei
                    if(counter_ticks_for_voltage == 255){

                        counter_ticks_for_voltage = 0;
                        sei(); // Enable interrupts

                        voltage = estimate_voltage(1);
     82c:	30 93 02 01 	sts	0x0102, r19	; 0x800102 <voltage+0x1>
     830:	20 93 01 01 	sts	0x0101, r18	; 0x800101 <voltage>

                        if(voltage != -1 && voltage < LOW_VOLTAGE_THRESHOLD){
     834:	2f 3f       	cpi	r18, 0xFF	; 255
     836:	8f ef       	ldi	r24, 0xFF	; 255
     838:	38 07       	cpc	r19, r24
     83a:	09 f4       	brne	.+2      	; 0x83e <__LOCK_REGION_LENGTH__+0x43e>
     83c:	f6 cd       	rjmp	.-1044   	; 0x42a <__LOCK_REGION_LENGTH__+0x2a>
     83e:	23 32       	cpi	r18, 0x23	; 35
     840:	32 40       	sbci	r19, 0x02	; 2
     842:	5c f5       	brge	.+86     	; 0x89a <__LOCK_REGION_LENGTH__+0x49a>

                            is_in_low_voltage++;
     844:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <is_in_low_voltage>
     848:	8f 5f       	subi	r24, 0xFF	; 255
     84a:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <is_in_low_voltage>
     84e:	ed cd       	rjmp	.-1062   	; 0x42a <__LOCK_REGION_LENGTH__+0x2a>
                        is_in_low_voltage++;

                    }
                    else if(voltage != -1){

                        is_in_low_voltage = 0;
     850:	10 92 0f 01 	sts	0x010F, r1	; 0x80010f <is_in_low_voltage>
                        
                    }

                    if(voltage > 682)
     854:	2b 3a       	cpi	r18, 0xAB	; 171
     856:	92 e0       	ldi	r25, 0x02	; 2
     858:	39 07       	cpc	r19, r25
     85a:	0c f4       	brge	.+2      	; 0x85e <__LOCK_REGION_LENGTH__+0x45e>
     85c:	5b ce       	rjmp	.-842    	; 0x514 <__LOCK_REGION_LENGTH__+0x114>

void set_color(uint8_t rgb) {
    if (rgb&(1<<0))
        DDRD |= (1<<5);
    else
        DDRD &= ~(1<<5);
     85e:	55 98       	cbi	0x0a, 5	; 10

    if (rgb&(1<<1))
        DDRD |= (1<<4);
    else
        DDRD &= ~(1<<4);
     860:	54 98       	cbi	0x0a, 4	; 10

    if (rgb&(1<<2))
        DDRC |= (1<<3);
     862:	3b 9a       	sbi	0x07, 3	; 7
    else
        DDRC &= ~(1<<3);

    if (rgb&(1<<3))
        DDRC |= (1<<2);
     864:	3a 9a       	sbi	0x07, 2	; 7
        DDRC &= ~(1<<2);

    if (rgb&(1<<4))
        DDRC |= (1<<5);
    else
        DDRC &= ~(1<<5);
     866:	3d 98       	cbi	0x07, 5	; 7

    if (rgb&(1<<5))
        DDRC |= (1<<4);
    else
        DDRC &= ~(1<<4);
     868:	3c 98       	cbi	0x07, 4	; 7
     86a:	aa cd       	rjmp	.-1196   	; 0x3c0 <kilo_start+0x50>
     86c:	ef e2       	ldi	r30, 0x2F	; 47
     86e:	f5 e7       	ldi	r31, 0x75	; 117
     870:	31 97       	sbiw	r30, 0x01	; 1
     872:	f1 f7       	brne	.-4      	; 0x870 <__LOCK_REGION_LENGTH__+0x470>
     874:	00 c0       	rjmp	.+0      	; 0x876 <__LOCK_REGION_LENGTH__+0x476>
     876:	00 00       	nop
                            _delay_ms(15);
                            set_motors(kilo_turn_left, 0);
                        } else if (cur_motion == MOVE_RIGHT) {
                            set_motors(0, 0xFF);
                            _delay_ms(15);
                            set_motors(0, kilo_turn_right);
     878:	80 91 5d 01 	lds	r24, 0x015D	; 0x80015d <kilo_turn_right>
        ms--;
    }
}

void set_motors(uint8_t ccw, uint8_t cw) {
    OCR2A = ccw;
     87c:	10 92 b3 00 	sts	0x00B3, r1	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
    OCR2B = cw;
     880:	80 93 b4 00 	sts	0x00B4, r24	; 0x8000b4 <__DATA_REGION_ORIGIN__+0x54>
     884:	89 cd       	rjmp	.-1262   	; 0x398 <kilo_start+0x28>
void rand_seed(uint8_t s) {
    seed = s;
}

int16_t get_voltage() {
    int16_t voltage=-1;
     886:	4f ef       	ldi	r20, 0xFF	; 255
     888:	5f ef       	ldi	r21, 0xFF	; 255
     88a:	2b ce       	rjmp	.-938    	; 0x4e2 <__LOCK_REGION_LENGTH__+0xe2>

#endif

void set_color(uint8_t rgb) {
    if (rgb&(1<<0))
        DDRD |= (1<<5);
     88c:	55 9a       	sbi	0x0a, 5	; 10
    else
        DDRD &= ~(1<<5);

    if (rgb&(1<<1))
        DDRD |= (1<<4);
     88e:	54 9a       	sbi	0x0a, 4	; 10
    else
        DDRD &= ~(1<<4);

    if (rgb&(1<<2))
        DDRC |= (1<<3);
     890:	3b 9a       	sbi	0x07, 3	; 7
    else
        DDRC &= ~(1<<3);

    if (rgb&(1<<3))
        DDRC |= (1<<2);
     892:	3a 9a       	sbi	0x07, 2	; 7
    else
        DDRC &= ~(1<<2);

    if (rgb&(1<<4))
        DDRC |= (1<<5);
     894:	3d 9a       	sbi	0x07, 5	; 7
    else
        DDRC &= ~(1<<5);

    if (rgb&(1<<5))
        DDRC |= (1<<4);
     896:	3c 9a       	sbi	0x07, 4	; 7
     898:	93 cd       	rjmp	.-1242   	; 0x3c0 <kilo_start+0x50>
                            is_in_low_voltage++;

                        }
                        else if(voltage != -1){

                            is_in_low_voltage = 0;
     89a:	10 92 0f 01 	sts	0x010F, r1	; 0x80010f <is_in_low_voltage>
     89e:	c5 cd       	rjmp	.-1142   	; 0x42a <__LOCK_REGION_LENGTH__+0x2a>

void set_color(uint8_t rgb) {
    if (rgb&(1<<0))
        DDRD |= (1<<5);
    else
        DDRD &= ~(1<<5);
     8a0:	55 98       	cbi	0x0a, 5	; 10

    if (rgb&(1<<1))
        DDRD |= (1<<4);
    else
        DDRD &= ~(1<<4);
     8a2:	54 98       	cbi	0x0a, 4	; 10

    if (rgb&(1<<2))
        DDRC |= (1<<3);
    else
        DDRC &= ~(1<<3);
     8a4:	3b 98       	cbi	0x07, 3	; 7

    if (rgb&(1<<3))
        DDRC |= (1<<2);
    else
        DDRC &= ~(1<<2);
     8a6:	3a 98       	cbi	0x07, 2	; 7

    if (rgb&(1<<4))
        DDRC |= (1<<5);
     8a8:	3d 9a       	sbi	0x07, 5	; 7
    else
        DDRC &= ~(1<<5);

    if (rgb&(1<<5))
        DDRC |= (1<<4);
     8aa:	3c 9a       	sbi	0x07, 4	; 7
     8ac:	89 cd       	rjmp	.-1262   	; 0x3c0 <kilo_start+0x50>
        ms--;
    }
}

void set_motors(uint8_t ccw, uint8_t cw) {
    OCR2A = ccw;
     8ae:	90 92 b3 00 	sts	0x00B3, r9	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
    OCR2B = cw;
     8b2:	10 92 b4 00 	sts	0x00B4, r1	; 0x8000b4 <__DATA_REGION_ORIGIN__+0x54>
     8b6:	8f e2       	ldi	r24, 0x2F	; 47
     8b8:	95 e7       	ldi	r25, 0x75	; 117
     8ba:	01 97       	sbiw	r24, 0x01	; 1
     8bc:	f1 f7       	brne	.-4      	; 0x8ba <__LOCK_REGION_LENGTH__+0x4ba>
     8be:	00 c0       	rjmp	.+0      	; 0x8c0 <__LOCK_REGION_LENGTH__+0x4c0>
     8c0:	00 00       	nop
                    if (cur_motion != prev_motion) {
                        prev_motion = cur_motion;
                        if (cur_motion == MOVE_LEFT) {
                            set_motors(0xFF, 0);
                            _delay_ms(15);
                            set_motors(kilo_turn_left, 0);
     8c2:	80 91 72 01 	lds	r24, 0x0172	; 0x800172 <kilo_turn_left>
        ms--;
    }
}

void set_motors(uint8_t ccw, uint8_t cw) {
    OCR2A = ccw;
     8c6:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
    OCR2B = cw;
     8ca:	10 92 b4 00 	sts	0x00B4, r1	; 0x8000b4 <__DATA_REGION_ORIGIN__+0x54>
     8ce:	64 cd       	rjmp	.-1336   	; 0x398 <kilo_start+0x28>
void rand_seed(uint8_t s) {
    seed = s;
}

int16_t get_voltage() {
    int16_t voltage=-1;
     8d0:	4f ef       	ldi	r20, 0xFF	; 255
     8d2:	5f ef       	ldi	r21, 0xFF	; 255
     8d4:	9d cf       	rjmp	.-198    	; 0x810 <__LOCK_REGION_LENGTH__+0x410>

000008d6 <delay>:
                break;
        }
    }
}

void delay(uint16_t ms) {
     8d6:	07 c0       	rjmp	.+14     	; 0x8e6 <delay+0x10>
     8d8:	ef ec       	ldi	r30, 0xCF	; 207
     8da:	f7 e0       	ldi	r31, 0x07	; 7
     8dc:	31 97       	sbiw	r30, 0x01	; 1
     8de:	f1 f7       	brne	.-4      	; 0x8dc <delay+0x6>
     8e0:	00 c0       	rjmp	.+0      	; 0x8e2 <delay+0xc>
     8e2:	00 00       	nop
    while (ms > 0) {
        _delay_ms(1);
        ms--;
     8e4:	01 97       	sbiw	r24, 0x01	; 1
        }
    }
}

void delay(uint16_t ms) {
    while (ms > 0) {
     8e6:	00 97       	sbiw	r24, 0x00	; 0
     8e8:	b9 f7       	brne	.-18     	; 0x8d8 <delay+0x2>
     8ea:	08 95       	ret

000008ec <set_motors>:
        ms--;
    }
}

void set_motors(uint8_t ccw, uint8_t cw) {
    OCR2A = ccw;
     8ec:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
    OCR2B = cw;
     8f0:	60 93 b4 00 	sts	0x00B4, r22	; 0x8000b4 <__DATA_REGION_ORIGIN__+0x54>
     8f4:	08 95       	ret

000008f6 <spinup_motors>:
        ms--;
    }
}

void set_motors(uint8_t ccw, uint8_t cw) {
    OCR2A = ccw;
     8f6:	8f ef       	ldi	r24, 0xFF	; 255
     8f8:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
    OCR2B = cw;
     8fc:	80 93 b4 00 	sts	0x00B4, r24	; 0x8000b4 <__DATA_REGION_ORIGIN__+0x54>
     900:	8f e0       	ldi	r24, 0x0F	; 15
     902:	90 e0       	ldi	r25, 0x00	; 0
     904:	ef ec       	ldi	r30, 0xCF	; 207
     906:	f7 e0       	ldi	r31, 0x07	; 7
     908:	31 97       	sbiw	r30, 0x01	; 1
     90a:	f1 f7       	brne	.-4      	; 0x908 <__stack+0x9>
     90c:	00 c0       	rjmp	.+0      	; 0x90e <__stack+0xf>
     90e:	00 00       	nop
     910:	01 97       	sbiw	r24, 0x01	; 1
        }
    }
}

void delay(uint16_t ms) {
    while (ms > 0) {
     912:	c1 f7       	brne	.-16     	; 0x904 <__stack+0x5>
}

void spinup_motors() {
    set_motors(255, 255);
    delay(15);
}
     914:	08 95       	ret

00000916 <get_ambientlight>:

int16_t get_ambientlight() {
    int16_t light = -1;
    if (!rx_busy) {
     916:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <rx_busy>
     91a:	81 11       	cpse	r24, r1
     91c:	1e c0       	rjmp	.+60     	; 0x95a <get_ambientlight+0x44>
        cli();
     91e:	f8 94       	cli
        adc_setup_conversion(7);
     920:	87 e0       	ldi	r24, 0x07	; 7
     922:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__DATA_REGION_ORIGIN__+0x1c>
     926:	83 e8       	ldi	r24, 0x83	; 131
     928:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
        adc_start_conversion();
     92c:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
     930:	80 64       	ori	r24, 0x40	; 64
     932:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
        adc_finish_conversion();
     936:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
     93a:	86 fd       	sbrc	r24, 6
     93c:	fc cf       	rjmp	.-8      	; 0x936 <get_ambientlight+0x20>
        light = ADCW;                             // store AD result
     93e:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__DATA_REGION_ORIGIN__+0x18>
     942:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__DATA_REGION_ORIGIN__+0x19>
        adc_trigger_high_gain();                     // set AD to measure high gain (for distance sensing)
     946:	10 92 7c 00 	sts	0x007C, r1	; 0x80007c <__DATA_REGION_ORIGIN__+0x1c>
     94a:	23 ea       	ldi	r18, 0xA3	; 163
     94c:	20 93 7a 00 	sts	0x007A, r18	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
     950:	21 e0       	ldi	r18, 0x01	; 1
     952:	20 93 7b 00 	sts	0x007B, r18	; 0x80007b <__DATA_REGION_ORIGIN__+0x1b>
        sei();                                    // reenable interrupts
     956:	78 94       	sei
     958:	08 95       	ret
    set_motors(255, 255);
    delay(15);
}

int16_t get_ambientlight() {
    int16_t light = -1;
     95a:	8f ef       	ldi	r24, 0xFF	; 255
     95c:	9f ef       	ldi	r25, 0xFF	; 255
        light = ADCW;                             // store AD result
        adc_trigger_high_gain();                     // set AD to measure high gain (for distance sensing)
        sei();                                    // reenable interrupts
    }
    return light;
}
     95e:	08 95       	ret

00000960 <get_temperature>:

int16_t get_temperature() {
    int16_t temp = -1;
    if (!rx_busy) {
     960:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <rx_busy>
     964:	81 11       	cpse	r24, r1
     966:	1e c0       	rjmp	.+60     	; 0x9a4 <get_temperature+0x44>
        cli();
     968:	f8 94       	cli
        ADMUX = (1<<3)|(1<<6)|(1<<7);
     96a:	88 ec       	ldi	r24, 0xC8	; 200
     96c:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__DATA_REGION_ORIGIN__+0x1c>
        ADCSRA = (1<<ADEN)|(1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0);
     970:	87 e8       	ldi	r24, 0x87	; 135
     972:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
        adc_start_conversion();
     976:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
     97a:	80 64       	ori	r24, 0x40	; 64
     97c:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
        adc_finish_conversion();
     980:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
     984:	86 fd       	sbrc	r24, 6
     986:	fc cf       	rjmp	.-8      	; 0x980 <get_temperature+0x20>
        temp = ADCW;                             // store AD result
     988:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__DATA_REGION_ORIGIN__+0x18>
     98c:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__DATA_REGION_ORIGIN__+0x19>
        adc_trigger_high_gain();                     // set AD to measure high gain (for distance sensing)
     990:	10 92 7c 00 	sts	0x007C, r1	; 0x80007c <__DATA_REGION_ORIGIN__+0x1c>
     994:	23 ea       	ldi	r18, 0xA3	; 163
     996:	20 93 7a 00 	sts	0x007A, r18	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
     99a:	21 e0       	ldi	r18, 0x01	; 1
     99c:	20 93 7b 00 	sts	0x007B, r18	; 0x80007b <__DATA_REGION_ORIGIN__+0x1b>
        sei();                                    // reenable interrupts
     9a0:	78 94       	sei
     9a2:	08 95       	ret
    }
    return light;
}

int16_t get_temperature() {
    int16_t temp = -1;
     9a4:	8f ef       	ldi	r24, 0xFF	; 255
     9a6:	9f ef       	ldi	r25, 0xFF	; 255
        temp = ADCW;                             // store AD result
        adc_trigger_high_gain();                     // set AD to measure high gain (for distance sensing)
        sei();                                    // reenable interrupts
    }
    return temp;
}
     9a8:	08 95       	ret

000009aa <rand_hard>:

uint8_t rand_hard() {
     9aa:	0f 93       	push	r16
     9ac:	1f 93       	push	r17
     9ae:	cf 93       	push	r28
     9b0:	df 93       	push	r29
     9b2:	e0 e0       	ldi	r30, 0x00	; 0
     9b4:	f0 e0       	ldi	r31, 0x00	; 0
    uint8_t num = 0;
     9b6:	80 e0       	ldi	r24, 0x00	; 0
            adc_finish_conversion();
            a = ADCW&0x1;
            adc_start_conversion();
            adc_finish_conversion();
            b = ADCW&0x1;
            adc_trigger_high_gain();
     9b8:	03 ea       	ldi	r16, 0xA3	; 163
     9ba:	11 e0       	ldi	r17, 0x01	; 1
    uint8_t a, b, i, tries;
    for (i = 0; i < 8; i++) {
        tries = 0;
        do {
            cli();
            adc_setup_conversion(6);
     9bc:	d6 e0       	ldi	r29, 0x06	; 6
     9be:	c3 e8       	ldi	r28, 0x83	; 131
            adc_trigger_high_gain();
            sei();
            tries++;
        } while (a == b && tries < 128);
        if (a)
            num |= (1<<i);
     9c0:	a1 e0       	ldi	r26, 0x01	; 1
     9c2:	b0 e0       	ldi	r27, 0x00	; 0
    }
    return temp;
}

uint8_t rand_hard() {
    uint8_t num = 0;
     9c4:	60 e8       	ldi	r22, 0x80	; 128
     9c6:	70 e0       	ldi	r23, 0x00	; 0
    uint8_t a, b, i, tries;
    for (i = 0; i < 8; i++) {
        tries = 0;
        do {
            cli();
     9c8:	f8 94       	cli
            adc_setup_conversion(6);
     9ca:	d0 93 7c 00 	sts	0x007C, r29	; 0x80007c <__DATA_REGION_ORIGIN__+0x1c>
     9ce:	c0 93 7a 00 	sts	0x007A, r28	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
            adc_start_conversion();
     9d2:	90 91 7a 00 	lds	r25, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
     9d6:	90 64       	ori	r25, 0x40	; 64
     9d8:	90 93 7a 00 	sts	0x007A, r25	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
            adc_finish_conversion();
     9dc:	90 91 7a 00 	lds	r25, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
     9e0:	96 fd       	sbrc	r25, 6
     9e2:	fc cf       	rjmp	.-8      	; 0x9dc <rand_hard+0x32>
            a = ADCW&0x1;
     9e4:	20 91 78 00 	lds	r18, 0x0078	; 0x800078 <__DATA_REGION_ORIGIN__+0x18>
     9e8:	30 91 79 00 	lds	r19, 0x0079	; 0x800079 <__DATA_REGION_ORIGIN__+0x19>
     9ec:	21 70       	andi	r18, 0x01	; 1
            adc_start_conversion();
     9ee:	90 91 7a 00 	lds	r25, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
     9f2:	90 64       	ori	r25, 0x40	; 64
     9f4:	90 93 7a 00 	sts	0x007A, r25	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
            adc_finish_conversion();
     9f8:	90 91 7a 00 	lds	r25, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
     9fc:	96 fd       	sbrc	r25, 6
     9fe:	fc cf       	rjmp	.-8      	; 0x9f8 <rand_hard+0x4e>
            b = ADCW&0x1;
     a00:	40 91 78 00 	lds	r20, 0x0078	; 0x800078 <__DATA_REGION_ORIGIN__+0x18>
     a04:	50 91 79 00 	lds	r21, 0x0079	; 0x800079 <__DATA_REGION_ORIGIN__+0x19>
            adc_trigger_high_gain();
     a08:	10 92 7c 00 	sts	0x007C, r1	; 0x80007c <__DATA_REGION_ORIGIN__+0x1c>
     a0c:	00 93 7a 00 	sts	0x007A, r16	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
     a10:	10 93 7b 00 	sts	0x007B, r17	; 0x80007b <__DATA_REGION_ORIGIN__+0x1b>
            sei();
     a14:	78 94       	sei
            tries++;
        } while (a == b && tries < 128);
     a16:	41 70       	andi	r20, 0x01	; 1
     a18:	24 13       	cpse	r18, r20
     a1a:	03 c0       	rjmp	.+6      	; 0xa22 <rand_hard+0x78>
     a1c:	61 50       	subi	r22, 0x01	; 1
     a1e:	71 09       	sbc	r23, r1
     a20:	99 f6       	brne	.-90     	; 0x9c8 <rand_hard+0x1e>
        if (a)
     a22:	22 23       	and	r18, r18
     a24:	39 f0       	breq	.+14     	; 0xa34 <rand_hard+0x8a>
            num |= (1<<i);
     a26:	9d 01       	movw	r18, r26
     a28:	0e 2e       	mov	r0, r30
     a2a:	01 c0       	rjmp	.+2      	; 0xa2e <rand_hard+0x84>
     a2c:	22 0f       	add	r18, r18
     a2e:	0a 94       	dec	r0
     a30:	ea f7       	brpl	.-6      	; 0xa2c <rand_hard+0x82>
     a32:	82 2b       	or	r24, r18
     a34:	31 96       	adiw	r30, 0x01	; 1
}

uint8_t rand_hard() {
    uint8_t num = 0;
    uint8_t a, b, i, tries;
    for (i = 0; i < 8; i++) {
     a36:	e8 30       	cpi	r30, 0x08	; 8
     a38:	f1 05       	cpc	r31, r1
     a3a:	09 f0       	breq	.+2      	; 0xa3e <rand_hard+0x94>
     a3c:	c3 cf       	rjmp	.-122    	; 0x9c4 <rand_hard+0x1a>
        } while (a == b && tries < 128);
        if (a)
            num |= (1<<i);
    }
    return num;
}
     a3e:	df 91       	pop	r29
     a40:	cf 91       	pop	r28
     a42:	1f 91       	pop	r17
     a44:	0f 91       	pop	r16
     a46:	08 95       	ret

00000a48 <rand_soft>:

static uint8_t seed=0xaa, accumulator = 0;

uint8_t rand_soft() {
    seed ^= seed<<3;
     a48:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     a4c:	98 2f       	mov	r25, r24
     a4e:	99 0f       	add	r25, r25
     a50:	99 0f       	add	r25, r25
     a52:	99 0f       	add	r25, r25
     a54:	89 27       	eor	r24, r25
    seed ^= seed>>5;
    seed ^= accumulator++>>2;
     a56:	90 91 10 01 	lds	r25, 0x0110	; 0x800110 <accumulator>
     a5a:	21 e0       	ldi	r18, 0x01	; 1
     a5c:	29 0f       	add	r18, r25
     a5e:	20 93 10 01 	sts	0x0110, r18	; 0x800110 <accumulator>
     a62:	28 2f       	mov	r18, r24
     a64:	22 95       	swap	r18
     a66:	26 95       	lsr	r18
     a68:	27 70       	andi	r18, 0x07	; 7
     a6a:	82 27       	eor	r24, r18
     a6c:	96 95       	lsr	r25
     a6e:	96 95       	lsr	r25
     a70:	89 27       	eor	r24, r25
     a72:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
    return seed;
}
     a76:	08 95       	ret

00000a78 <rand_seed>:

void rand_seed(uint8_t s) {
    seed = s;
     a78:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
     a7c:	08 95       	ret

00000a7e <get_voltage>:
}

int16_t get_voltage() {
    int16_t voltage=-1;
    if (!rx_busy) {
     a7e:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <rx_busy>
     a82:	81 11       	cpse	r24, r1
     a84:	16 c0       	rjmp	.+44     	; 0xab2 <get_voltage+0x34>
        cli();                                    // disable interrupts
     a86:	f8 94       	cli
        adc_setup_conversion(6);
     a88:	86 e0       	ldi	r24, 0x06	; 6
     a8a:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__DATA_REGION_ORIGIN__+0x1c>
     a8e:	83 e8       	ldi	r24, 0x83	; 131
     a90:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
        adc_start_conversion();
     a94:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
     a98:	80 64       	ori	r24, 0x40	; 64
     a9a:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
        adc_finish_conversion();
     a9e:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
     aa2:	86 fd       	sbrc	r24, 6
     aa4:	fc cf       	rjmp	.-8      	; 0xa9e <get_voltage+0x20>
        voltage = ADCW;                           // store AD result
     aa6:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__DATA_REGION_ORIGIN__+0x18>
     aaa:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__DATA_REGION_ORIGIN__+0x19>
        
        //adc_trigger_high_gain();                     // set AD to measure high gain (for distance sensing)
            
        sei();                                    // reenable interrupts
     aae:	78 94       	sei
     ab0:	08 95       	ret
void rand_seed(uint8_t s) {
    seed = s;
}

int16_t get_voltage() {
    int16_t voltage=-1;
     ab2:	8f ef       	ldi	r24, 0xFF	; 255
     ab4:	9f ef       	ldi	r25, 0xFF	; 255
        //adc_trigger_high_gain();                     // set AD to measure high gain (for distance sensing)
            
        sei();                                    // reenable interrupts
    }
    return voltage;
}
     ab6:	08 95       	ret

00000ab8 <estimate_distance>:

uint8_t estimate_distance(const distance_measurement_t *dist) {
     ab8:	2f 92       	push	r2
     aba:	3f 92       	push	r3
     abc:	4f 92       	push	r4
     abe:	5f 92       	push	r5
     ac0:	6f 92       	push	r6
     ac2:	7f 92       	push	r7
     ac4:	8f 92       	push	r8
     ac6:	9f 92       	push	r9
     ac8:	af 92       	push	r10
     aca:	bf 92       	push	r11
     acc:	cf 92       	push	r12
     ace:	df 92       	push	r13
     ad0:	ef 92       	push	r14
     ad2:	ff 92       	push	r15
     ad4:	0f 93       	push	r16
     ad6:	1f 93       	push	r17
     ad8:	cf 93       	push	r28
     ada:	df 93       	push	r29
     adc:	00 d0       	rcall	.+0      	; 0xade <estimate_distance+0x26>
     ade:	00 d0       	rcall	.+0      	; 0xae0 <estimate_distance+0x28>
     ae0:	00 d0       	rcall	.+0      	; 0xae2 <estimate_distance+0x2a>
     ae2:	cd b7       	in	r28, 0x3d	; 61
     ae4:	de b7       	in	r29, 0x3e	; 62
     ae6:	1c 01       	movw	r2, r24
    uint8_t index_high=13;
    uint8_t index_low=255;
    uint8_t dist_high=255;
    uint8_t dist_low=255;

    if (dist->high_gain < 900) {
     ae8:	dc 01       	movw	r26, r24
     aea:	12 96       	adiw	r26, 0x02	; 2
     aec:	0d 90       	ld	r0, X+
     aee:	bc 91       	ld	r27, X
     af0:	a0 2d       	mov	r26, r0
     af2:	be 83       	std	Y+6, r27	; 0x06
     af4:	ad 83       	std	Y+5, r26	; 0x05
     af6:	a4 38       	cpi	r26, 0x84	; 132
     af8:	e3 e0       	ldi	r30, 0x03	; 3
     afa:	be 07       	cpc	r27, r30
     afc:	0c f0       	brlt	.+2      	; 0xb00 <estimate_distance+0x48>
     afe:	cb c0       	rjmp	.+406    	; 0xc96 <estimate_distance+0x1de>
        if (dist->high_gain > kilo_irhigh[0]) {
     b00:	80 91 15 01 	lds	r24, 0x0115	; 0x800115 <kilo_irhigh>
     b04:	90 91 16 01 	lds	r25, 0x0116	; 0x800116 <kilo_irhigh+0x1>
     b08:	8a 17       	cp	r24, r26
     b0a:	9b 07       	cpc	r25, r27
     b0c:	08 f4       	brcc	.+2      	; 0xb10 <estimate_distance+0x58>
     b0e:	8c c1       	rjmp	.+792    	; 0xe28 <estimate_distance+0x370>
            dist_high=0;
        } else {
            for (i=1; i<14; i++) {
                if (dist->high_gain > kilo_irhigh[i]) {
     b10:	00 91 17 01 	lds	r16, 0x0117	; 0x800117 <kilo_irhigh+0x2>
     b14:	10 91 18 01 	lds	r17, 0x0118	; 0x800118 <kilo_irhigh+0x3>
     b18:	0a 17       	cp	r16, r26
     b1a:	1b 07       	cpc	r17, r27
     b1c:	08 f4       	brcc	.+2      	; 0xb20 <estimate_distance+0x68>
     b1e:	22 c2       	rjmp	.+1092   	; 0xf64 <estimate_distance+0x4ac>
     b20:	00 91 19 01 	lds	r16, 0x0119	; 0x800119 <kilo_irhigh+0x4>
     b24:	10 91 1a 01 	lds	r17, 0x011A	; 0x80011a <kilo_irhigh+0x5>
     b28:	0a 17       	cp	r16, r26
     b2a:	1b 07       	cpc	r17, r27
     b2c:	08 f4       	brcc	.+2      	; 0xb30 <estimate_distance+0x78>
     b2e:	28 c2       	rjmp	.+1104   	; 0xf80 <estimate_distance+0x4c8>
     b30:	00 91 1b 01 	lds	r16, 0x011B	; 0x80011b <kilo_irhigh+0x6>
     b34:	10 91 1c 01 	lds	r17, 0x011C	; 0x80011c <kilo_irhigh+0x7>
     b38:	0a 17       	cp	r16, r26
     b3a:	1b 07       	cpc	r17, r27
     b3c:	08 f4       	brcc	.+2      	; 0xb40 <estimate_distance+0x88>
     b3e:	24 c2       	rjmp	.+1096   	; 0xf88 <estimate_distance+0x4d0>
     b40:	00 91 1d 01 	lds	r16, 0x011D	; 0x80011d <kilo_irhigh+0x8>
     b44:	10 91 1e 01 	lds	r17, 0x011E	; 0x80011e <kilo_irhigh+0x9>
     b48:	0a 17       	cp	r16, r26
     b4a:	1b 07       	cpc	r17, r27
     b4c:	08 f4       	brcc	.+2      	; 0xb50 <estimate_distance+0x98>
     b4e:	25 c2       	rjmp	.+1098   	; 0xf9a <estimate_distance+0x4e2>
     b50:	00 91 1f 01 	lds	r16, 0x011F	; 0x80011f <kilo_irhigh+0xa>
     b54:	10 91 20 01 	lds	r17, 0x0120	; 0x800120 <kilo_irhigh+0xb>
     b58:	0a 17       	cp	r16, r26
     b5a:	1b 07       	cpc	r17, r27
     b5c:	08 f4       	brcc	.+2      	; 0xb60 <estimate_distance+0xa8>
     b5e:	e6 c1       	rjmp	.+972    	; 0xf2c <estimate_distance+0x474>
     b60:	00 91 21 01 	lds	r16, 0x0121	; 0x800121 <kilo_irhigh+0xc>
     b64:	10 91 22 01 	lds	r17, 0x0122	; 0x800122 <kilo_irhigh+0xd>
     b68:	0a 17       	cp	r16, r26
     b6a:	1b 07       	cpc	r17, r27
     b6c:	08 f4       	brcc	.+2      	; 0xb70 <estimate_distance+0xb8>
     b6e:	1e c2       	rjmp	.+1084   	; 0xfac <estimate_distance+0x4f4>
     b70:	00 91 23 01 	lds	r16, 0x0123	; 0x800123 <kilo_irhigh+0xe>
     b74:	10 91 24 01 	lds	r17, 0x0124	; 0x800124 <kilo_irhigh+0xf>
     b78:	0a 17       	cp	r16, r26
     b7a:	1b 07       	cpc	r17, r27
     b7c:	08 f4       	brcc	.+2      	; 0xb80 <estimate_distance+0xc8>
     b7e:	1f c2       	rjmp	.+1086   	; 0xfbe <estimate_distance+0x506>
     b80:	00 91 25 01 	lds	r16, 0x0125	; 0x800125 <kilo_irhigh+0x10>
     b84:	10 91 26 01 	lds	r17, 0x0126	; 0x800126 <kilo_irhigh+0x11>
     b88:	0a 17       	cp	r16, r26
     b8a:	1b 07       	cpc	r17, r27
     b8c:	08 f4       	brcc	.+2      	; 0xb90 <estimate_distance+0xd8>
     b8e:	25 c2       	rjmp	.+1098   	; 0xfda <estimate_distance+0x522>
     b90:	00 91 27 01 	lds	r16, 0x0127	; 0x800127 <kilo_irhigh+0x12>
     b94:	10 91 28 01 	lds	r17, 0x0128	; 0x800128 <kilo_irhigh+0x13>
     b98:	0a 17       	cp	r16, r26
     b9a:	1b 07       	cpc	r17, r27
     b9c:	08 f4       	brcc	.+2      	; 0xba0 <estimate_distance+0xe8>
     b9e:	26 c2       	rjmp	.+1100   	; 0xfec <estimate_distance+0x534>
     ba0:	00 91 29 01 	lds	r16, 0x0129	; 0x800129 <kilo_irhigh+0x14>
     ba4:	10 91 2a 01 	lds	r17, 0x012A	; 0x80012a <kilo_irhigh+0x15>
     ba8:	0a 17       	cp	r16, r26
     baa:	1b 07       	cpc	r17, r27
     bac:	08 f4       	brcc	.+2      	; 0xbb0 <estimate_distance+0xf8>
     bae:	22 c2       	rjmp	.+1092   	; 0xff4 <estimate_distance+0x53c>
     bb0:	00 91 2b 01 	lds	r16, 0x012B	; 0x80012b <kilo_irhigh+0x16>
     bb4:	10 91 2c 01 	lds	r17, 0x012C	; 0x80012c <kilo_irhigh+0x17>
     bb8:	0a 17       	cp	r16, r26
     bba:	1b 07       	cpc	r17, r27
     bbc:	08 f4       	brcc	.+2      	; 0xbc0 <estimate_distance+0x108>
     bbe:	23 c2       	rjmp	.+1094   	; 0x1006 <estimate_distance+0x54e>
     bc0:	00 91 2d 01 	lds	r16, 0x012D	; 0x80012d <kilo_irhigh+0x18>
     bc4:	10 91 2e 01 	lds	r17, 0x012E	; 0x80012e <kilo_irhigh+0x19>
     bc8:	0a 17       	cp	r16, r26
     bca:	1b 07       	cpc	r17, r27
     bcc:	08 f4       	brcc	.+2      	; 0xbd0 <estimate_distance+0x118>
     bce:	24 c2       	rjmp	.+1096   	; 0x1018 <estimate_distance+0x560>
     bd0:	00 91 2f 01 	lds	r16, 0x012F	; 0x80012f <kilo_irhigh+0x1a>
     bd4:	10 91 30 01 	lds	r17, 0x0130	; 0x800130 <kilo_irhigh+0x1b>
     bd8:	0a 17       	cp	r16, r26
     bda:	1b 07       	cpc	r17, r27
     bdc:	08 f4       	brcc	.+2      	; 0xbe0 <estimate_distance+0x128>
     bde:	25 c2       	rjmp	.+1098   	; 0x102a <estimate_distance+0x572>
     be0:	80 e0       	ldi	r24, 0x00	; 0
     be2:	90 e0       	ldi	r25, 0x00	; 0
     be4:	a0 ed       	ldi	r26, 0xD0	; 208
     be6:	b0 e4       	ldi	r27, 0x40	; 64
     be8:	89 83       	std	Y+1, r24	; 0x01
     bea:	9a 83       	std	Y+2, r25	; 0x02
     bec:	ab 83       	std	Y+3, r26	; 0x03
     bee:	bc 83       	std	Y+4, r27	; 0x04
     bf0:	2c e0       	ldi	r18, 0x0C	; 12
     bf2:	e2 2e       	mov	r14, r18
     bf4:	f1 2c       	mov	r15, r1
                    index_high = i;
                    break;
                }
            }

            double slope=(kilo_irhigh[index_high]-kilo_irhigh[index_high-1])/0.5;
     bf6:	f7 01       	movw	r30, r14
     bf8:	ee 0f       	add	r30, r30
     bfa:	ff 1f       	adc	r31, r31
     bfc:	eb 5e       	subi	r30, 0xEB	; 235
     bfe:	fe 4f       	sbci	r31, 0xFE	; 254
     c00:	80 81       	ld	r24, Z
     c02:	91 81       	ldd	r25, Z+1	; 0x01
     c04:	b8 01       	movw	r22, r16
     c06:	68 1b       	sub	r22, r24
     c08:	79 0b       	sbc	r23, r25
     c0a:	80 e0       	ldi	r24, 0x00	; 0
     c0c:	90 e0       	ldi	r25, 0x00	; 0
     c0e:	0e 94 bd 0d 	call	0x1b7a	; 0x1b7a <__floatunsisf>
     c12:	9b 01       	movw	r18, r22
     c14:	ac 01       	movw	r20, r24
     c16:	0e 94 a9 0c 	call	0x1952	; 0x1952 <__addsf3>
     c1a:	6b 01       	movw	r12, r22
     c1c:	7c 01       	movw	r14, r24
            double b=(double)kilo_irhigh[index_high]-(double)slope*((double)index_high*(double)0.5+(double)0.0);
            b=(((((double)dist->high_gain-(double)b)*(double)10)));
     c1e:	ad 81       	ldd	r26, Y+5	; 0x05
     c20:	be 81       	ldd	r27, Y+6	; 0x06
     c22:	bd 01       	movw	r22, r26
     c24:	bb 0f       	add	r27, r27
     c26:	88 0b       	sbc	r24, r24
     c28:	99 0b       	sbc	r25, r25
     c2a:	0e 94 bf 0d 	call	0x1b7e	; 0x1b7e <__floatsisf>
     c2e:	4b 01       	movw	r8, r22
     c30:	5c 01       	movw	r10, r24
     c32:	b8 01       	movw	r22, r16
     c34:	80 e0       	ldi	r24, 0x00	; 0
     c36:	90 e0       	ldi	r25, 0x00	; 0
     c38:	0e 94 bd 0d 	call	0x1b7a	; 0x1b7a <__floatunsisf>
     c3c:	2b 01       	movw	r4, r22
     c3e:	3c 01       	movw	r6, r24
     c40:	29 81       	ldd	r18, Y+1	; 0x01
     c42:	3a 81       	ldd	r19, Y+2	; 0x02
     c44:	4b 81       	ldd	r20, Y+3	; 0x03
     c46:	5c 81       	ldd	r21, Y+4	; 0x04
     c48:	c7 01       	movw	r24, r14
     c4a:	b6 01       	movw	r22, r12
     c4c:	0e 94 4b 0e 	call	0x1c96	; 0x1c96 <__mulsf3>
     c50:	9b 01       	movw	r18, r22
     c52:	ac 01       	movw	r20, r24
     c54:	c3 01       	movw	r24, r6
     c56:	b2 01       	movw	r22, r4
     c58:	0e 94 a8 0c 	call	0x1950	; 0x1950 <__subsf3>
     c5c:	9b 01       	movw	r18, r22
     c5e:	ac 01       	movw	r20, r24
     c60:	c5 01       	movw	r24, r10
     c62:	b4 01       	movw	r22, r8
     c64:	0e 94 a8 0c 	call	0x1950	; 0x1950 <__subsf3>
            b=((int)((int)b/(int)slope));
            dist_high=b;
     c68:	20 e0       	ldi	r18, 0x00	; 0
     c6a:	30 e0       	ldi	r19, 0x00	; 0
     c6c:	40 e2       	ldi	r20, 0x20	; 32
     c6e:	51 e4       	ldi	r21, 0x41	; 65
     c70:	0e 94 4b 0e 	call	0x1c96	; 0x1c96 <__mulsf3>
     c74:	0e 94 87 0d 	call	0x1b0e	; 0x1b0e <__fixsfsi>
     c78:	8b 01       	movw	r16, r22
     c7a:	c7 01       	movw	r24, r14
     c7c:	b6 01       	movw	r22, r12
     c7e:	0e 94 87 0d 	call	0x1b0e	; 0x1b0e <__fixsfsi>
     c82:	ab 01       	movw	r20, r22
     c84:	bc 01       	movw	r22, r24
     c86:	c8 01       	movw	r24, r16
     c88:	ba 01       	movw	r22, r20
     c8a:	0e 94 6b 0c 	call	0x18d6	; 0x18d6 <__divmodhi4>
     c8e:	69 83       	std	Y+1, r22	; 0x01
     c90:	ed 81       	ldd	r30, Y+5	; 0x05
     c92:	fe 81       	ldd	r31, Y+6	; 0x06
     c94:	cb c0       	rjmp	.+406    	; 0xe2c <estimate_distance+0x374>
        }
    }

    if (dist->high_gain > 700) {
        if (dist->low_gain > kilo_irlow[0]) {
     c96:	dc 01       	movw	r26, r24
     c98:	cd 90       	ld	r12, X+
     c9a:	dc 90       	ld	r13, X
     c9c:	80 91 3c 01 	lds	r24, 0x013C	; 0x80013c <kilo_irlow>
     ca0:	90 91 3d 01 	lds	r25, 0x013D	; 0x80013d <kilo_irlow+0x1>
     ca4:	8c 15       	cp	r24, r12
     ca6:	9d 05       	cpc	r25, r13
     ca8:	08 f4       	brcc	.+2      	; 0xcac <estimate_distance+0x1f4>
     caa:	df c0       	rjmp	.+446    	; 0xe6a <estimate_distance+0x3b2>
uint8_t estimate_distance(const distance_measurement_t *dist) {

    uint8_t i;
    uint8_t index_high=13;
    uint8_t index_low=255;
    uint8_t dist_high=255;
     cac:	bf ef       	ldi	r27, 0xFF	; 255
     cae:	b9 83       	std	Y+1, r27	; 0x01
    if (dist->high_gain > 700) {
        if (dist->low_gain > kilo_irlow[0]) {
            dist_low=0;
        } else {
            for(i=1; i<14; i++) {
                if(dist->low_gain > kilo_irlow[i]) {
     cb0:	00 91 3e 01 	lds	r16, 0x013E	; 0x80013e <kilo_irlow+0x2>
     cb4:	10 91 3f 01 	lds	r17, 0x013F	; 0x80013f <kilo_irlow+0x3>
     cb8:	0c 15       	cp	r16, r12
     cba:	1d 05       	cpc	r17, r13
     cbc:	08 f4       	brcc	.+2      	; 0xcc0 <estimate_distance+0x208>
     cbe:	56 c1       	rjmp	.+684    	; 0xf6c <estimate_distance+0x4b4>
     cc0:	00 91 40 01 	lds	r16, 0x0140	; 0x800140 <kilo_irlow+0x4>
     cc4:	10 91 41 01 	lds	r17, 0x0141	; 0x800141 <kilo_irlow+0x5>
     cc8:	0c 15       	cp	r16, r12
     cca:	1d 05       	cpc	r17, r13
     ccc:	08 f4       	brcc	.+2      	; 0xcd0 <estimate_distance+0x218>
     cce:	53 c1       	rjmp	.+678    	; 0xf76 <estimate_distance+0x4be>
     cd0:	00 91 42 01 	lds	r16, 0x0142	; 0x800142 <kilo_irlow+0x6>
     cd4:	10 91 43 01 	lds	r17, 0x0143	; 0x800143 <kilo_irlow+0x7>
     cd8:	0c 15       	cp	r16, r12
     cda:	1d 05       	cpc	r17, r13
     cdc:	08 f4       	brcc	.+2      	; 0xce0 <estimate_distance+0x228>
     cde:	58 c1       	rjmp	.+688    	; 0xf90 <estimate_distance+0x4d8>
     ce0:	00 91 44 01 	lds	r16, 0x0144	; 0x800144 <kilo_irlow+0x8>
     ce4:	10 91 45 01 	lds	r17, 0x0145	; 0x800145 <kilo_irlow+0x9>
     ce8:	0c 15       	cp	r16, r12
     cea:	1d 05       	cpc	r17, r13
     cec:	08 f4       	brcc	.+2      	; 0xcf0 <estimate_distance+0x238>
     cee:	59 c1       	rjmp	.+690    	; 0xfa2 <estimate_distance+0x4ea>
     cf0:	00 91 46 01 	lds	r16, 0x0146	; 0x800146 <kilo_irlow+0xa>
     cf4:	10 91 47 01 	lds	r17, 0x0147	; 0x800147 <kilo_irlow+0xb>
     cf8:	0c 15       	cp	r16, r12
     cfa:	1d 05       	cpc	r17, r13
     cfc:	08 f4       	brcc	.+2      	; 0xd00 <estimate_distance+0x248>
     cfe:	b7 c0       	rjmp	.+366    	; 0xe6e <estimate_distance+0x3b6>
     d00:	00 91 48 01 	lds	r16, 0x0148	; 0x800148 <kilo_irlow+0xc>
     d04:	10 91 49 01 	lds	r17, 0x0149	; 0x800149 <kilo_irlow+0xd>
     d08:	0c 15       	cp	r16, r12
     d0a:	1d 05       	cpc	r17, r13
     d0c:	08 f4       	brcc	.+2      	; 0xd10 <estimate_distance+0x258>
     d0e:	52 c1       	rjmp	.+676    	; 0xfb4 <estimate_distance+0x4fc>
     d10:	00 91 4a 01 	lds	r16, 0x014A	; 0x80014a <kilo_irlow+0xe>
     d14:	10 91 4b 01 	lds	r17, 0x014B	; 0x80014b <kilo_irlow+0xf>
     d18:	0c 15       	cp	r16, r12
     d1a:	1d 05       	cpc	r17, r13
     d1c:	08 f4       	brcc	.+2      	; 0xd20 <estimate_distance+0x268>
     d1e:	53 c1       	rjmp	.+678    	; 0xfc6 <estimate_distance+0x50e>
     d20:	00 91 4c 01 	lds	r16, 0x014C	; 0x80014c <kilo_irlow+0x10>
     d24:	10 91 4d 01 	lds	r17, 0x014D	; 0x80014d <kilo_irlow+0x11>
     d28:	0c 15       	cp	r16, r12
     d2a:	1d 05       	cpc	r17, r13
     d2c:	08 f4       	brcc	.+2      	; 0xd30 <estimate_distance+0x278>
     d2e:	50 c1       	rjmp	.+672    	; 0xfd0 <estimate_distance+0x518>
     d30:	00 91 4e 01 	lds	r16, 0x014E	; 0x80014e <kilo_irlow+0x12>
     d34:	10 91 4f 01 	lds	r17, 0x014F	; 0x80014f <kilo_irlow+0x13>
     d38:	0c 15       	cp	r16, r12
     d3a:	1d 05       	cpc	r17, r13
     d3c:	08 f4       	brcc	.+2      	; 0xd40 <estimate_distance+0x288>
     d3e:	51 c1       	rjmp	.+674    	; 0xfe2 <estimate_distance+0x52a>
     d40:	00 91 50 01 	lds	r16, 0x0150	; 0x800150 <kilo_irlow+0x14>
     d44:	10 91 51 01 	lds	r17, 0x0151	; 0x800151 <kilo_irlow+0x15>
     d48:	0c 15       	cp	r16, r12
     d4a:	1d 05       	cpc	r17, r13
     d4c:	08 f4       	brcc	.+2      	; 0xd50 <estimate_distance+0x298>
     d4e:	56 c1       	rjmp	.+684    	; 0xffc <estimate_distance+0x544>
     d50:	00 91 52 01 	lds	r16, 0x0152	; 0x800152 <kilo_irlow+0x16>
     d54:	10 91 53 01 	lds	r17, 0x0153	; 0x800153 <kilo_irlow+0x17>
     d58:	0c 15       	cp	r16, r12
     d5a:	1d 05       	cpc	r17, r13
     d5c:	08 f4       	brcc	.+2      	; 0xd60 <estimate_distance+0x2a8>
     d5e:	57 c1       	rjmp	.+686    	; 0x100e <estimate_distance+0x556>
     d60:	00 91 54 01 	lds	r16, 0x0154	; 0x800154 <kilo_irlow+0x18>
     d64:	10 91 55 01 	lds	r17, 0x0155	; 0x800155 <kilo_irlow+0x19>
     d68:	0c 15       	cp	r16, r12
     d6a:	1d 05       	cpc	r17, r13
     d6c:	08 f4       	brcc	.+2      	; 0xd70 <estimate_distance+0x2b8>
     d6e:	58 c1       	rjmp	.+688    	; 0x1020 <estimate_distance+0x568>
     d70:	00 91 56 01 	lds	r16, 0x0156	; 0x800156 <kilo_irlow+0x1a>
     d74:	10 91 57 01 	lds	r17, 0x0157	; 0x800157 <kilo_irlow+0x1b>
     d78:	0c 15       	cp	r16, r12
     d7a:	1d 05       	cpc	r17, r13
     d7c:	08 f4       	brcc	.+2      	; 0xd80 <estimate_distance+0x2c8>
     d7e:	59 c1       	rjmp	.+690    	; 0x1032 <estimate_distance+0x57a>
                    break;
                }
            }

            if(index_low == 255) {
                dist_low=90;
     d80:	1a e5       	ldi	r17, 0x5A	; 90
            }
        }
    }

    if (dist_low != 255) {
        if (dist_high != 255) {
     d82:	b9 81       	ldd	r27, Y+1	; 0x01
     d84:	bf 3f       	cpi	r27, 0xFF	; 255
     d86:	09 f4       	brne	.+2      	; 0xd8a <estimate_distance+0x2d2>
     d88:	59 c1       	rjmp	.+690    	; 0x103c <estimate_distance+0x584>
            return 33 + ((double)dist_high*(900.0-dist->high_gain)+(double)dist_low*(dist->high_gain-700.0))/200.0;
     d8a:	ed 81       	ldd	r30, Y+5	; 0x05
     d8c:	fe 81       	ldd	r31, Y+6	; 0x06
     d8e:	bf 01       	movw	r22, r30
     d90:	ff 0f       	add	r31, r31
     d92:	88 0b       	sbc	r24, r24
     d94:	99 0b       	sbc	r25, r25
     d96:	0e 94 bf 0d 	call	0x1b7e	; 0x1b7e <__floatsisf>
     d9a:	4b 01       	movw	r8, r22
     d9c:	5c 01       	movw	r10, r24
     d9e:	f9 81       	ldd	r31, Y+1	; 0x01
     da0:	6f 2f       	mov	r22, r31
     da2:	70 e0       	ldi	r23, 0x00	; 0
     da4:	80 e0       	ldi	r24, 0x00	; 0
     da6:	90 e0       	ldi	r25, 0x00	; 0
     da8:	0e 94 bd 0d 	call	0x1b7a	; 0x1b7a <__floatunsisf>
     dac:	6b 01       	movw	r12, r22
     dae:	7c 01       	movw	r14, r24
     db0:	a5 01       	movw	r20, r10
     db2:	94 01       	movw	r18, r8
     db4:	60 e0       	ldi	r22, 0x00	; 0
     db6:	70 e0       	ldi	r23, 0x00	; 0
     db8:	81 e6       	ldi	r24, 0x61	; 97
     dba:	94 e4       	ldi	r25, 0x44	; 68
     dbc:	0e 94 a8 0c 	call	0x1950	; 0x1950 <__subsf3>
     dc0:	9b 01       	movw	r18, r22
     dc2:	ac 01       	movw	r20, r24
     dc4:	c7 01       	movw	r24, r14
     dc6:	b6 01       	movw	r22, r12
     dc8:	0e 94 4b 0e 	call	0x1c96	; 0x1c96 <__mulsf3>
     dcc:	6b 01       	movw	r12, r22
     dce:	7c 01       	movw	r14, r24
     dd0:	61 2f       	mov	r22, r17
     dd2:	70 e0       	ldi	r23, 0x00	; 0
     dd4:	80 e0       	ldi	r24, 0x00	; 0
     dd6:	90 e0       	ldi	r25, 0x00	; 0
     dd8:	0e 94 bd 0d 	call	0x1b7a	; 0x1b7a <__floatunsisf>
     ddc:	2b 01       	movw	r4, r22
     dde:	3c 01       	movw	r6, r24
     de0:	20 e0       	ldi	r18, 0x00	; 0
     de2:	30 e0       	ldi	r19, 0x00	; 0
     de4:	4f e2       	ldi	r20, 0x2F	; 47
     de6:	54 e4       	ldi	r21, 0x44	; 68
     de8:	c5 01       	movw	r24, r10
     dea:	b4 01       	movw	r22, r8
     dec:	0e 94 a8 0c 	call	0x1950	; 0x1950 <__subsf3>
     df0:	9b 01       	movw	r18, r22
     df2:	ac 01       	movw	r20, r24
     df4:	c3 01       	movw	r24, r6
     df6:	b2 01       	movw	r22, r4
     df8:	0e 94 4b 0e 	call	0x1c96	; 0x1c96 <__mulsf3>
     dfc:	9b 01       	movw	r18, r22
     dfe:	ac 01       	movw	r20, r24
     e00:	c7 01       	movw	r24, r14
     e02:	b6 01       	movw	r22, r12
     e04:	0e 94 a9 0c 	call	0x1952	; 0x1952 <__addsf3>
     e08:	20 e0       	ldi	r18, 0x00	; 0
     e0a:	30 e0       	ldi	r19, 0x00	; 0
     e0c:	48 e4       	ldi	r20, 0x48	; 72
     e0e:	53 e4       	ldi	r21, 0x43	; 67
     e10:	0e 94 15 0d 	call	0x1a2a	; 0x1a2a <__divsf3>
     e14:	20 e0       	ldi	r18, 0x00	; 0
     e16:	30 e0       	ldi	r19, 0x00	; 0
     e18:	44 e0       	ldi	r20, 0x04	; 4
     e1a:	52 e4       	ldi	r21, 0x42	; 66
     e1c:	0e 94 a9 0c 	call	0x1952	; 0x1952 <__addsf3>
     e20:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <__fixunssfsi>
     e24:	86 2f       	mov	r24, r22
     e26:	08 c0       	rjmp	.+16     	; 0xe38 <estimate_distance+0x380>
    uint8_t dist_high=255;
    uint8_t dist_low=255;

    if (dist->high_gain < 900) {
        if (dist->high_gain > kilo_irhigh[0]) {
            dist_high=0;
     e28:	19 82       	std	Y+1, r1	; 0x01
     e2a:	fd 01       	movw	r30, r26
            b=((int)((int)b/(int)slope));
            dist_high=b;
        }
    }

    if (dist->high_gain > 700) {
     e2c:	ed 3b       	cpi	r30, 0xBD	; 189
     e2e:	f2 40       	sbci	r31, 0x02	; 2
     e30:	0c f0       	brlt	.+2      	; 0xe34 <estimate_distance+0x37c>
     e32:	07 c1       	rjmp	.+526    	; 0x1042 <estimate_distance+0x58a>
            return 33 + ((double)dist_high*(900.0-dist->high_gain)+(double)dist_low*(dist->high_gain-700.0))/200.0;
        } else {
            return 33 + dist_low;
        }
    } else {
        return 33 + dist_high;
     e34:	89 81       	ldd	r24, Y+1	; 0x01
     e36:	8f 5d       	subi	r24, 0xDF	; 223
    }
}
     e38:	26 96       	adiw	r28, 0x06	; 6
     e3a:	0f b6       	in	r0, 0x3f	; 63
     e3c:	f8 94       	cli
     e3e:	de bf       	out	0x3e, r29	; 62
     e40:	0f be       	out	0x3f, r0	; 63
     e42:	cd bf       	out	0x3d, r28	; 61
     e44:	df 91       	pop	r29
     e46:	cf 91       	pop	r28
     e48:	1f 91       	pop	r17
     e4a:	0f 91       	pop	r16
     e4c:	ff 90       	pop	r15
     e4e:	ef 90       	pop	r14
     e50:	df 90       	pop	r13
     e52:	cf 90       	pop	r12
     e54:	bf 90       	pop	r11
     e56:	af 90       	pop	r10
     e58:	9f 90       	pop	r9
     e5a:	8f 90       	pop	r8
     e5c:	7f 90       	pop	r7
     e5e:	6f 90       	pop	r6
     e60:	5f 90       	pop	r5
     e62:	4f 90       	pop	r4
     e64:	3f 90       	pop	r3
     e66:	2f 90       	pop	r2
     e68:	08 95       	ret
            dist_high=b;
        }
    }

    if (dist->high_gain > 700) {
        if (dist->low_gain > kilo_irlow[0]) {
     e6a:	81 e2       	ldi	r24, 0x21	; 33

    if (dist_low != 255) {
        if (dist_high != 255) {
            return 33 + ((double)dist_high*(900.0-dist->high_gain)+(double)dist_low*(dist->high_gain-700.0))/200.0;
        } else {
            return 33 + dist_low;
     e6c:	e5 cf       	rjmp	.-54     	; 0xe38 <estimate_distance+0x380>

    if (dist->high_gain > 700) {
        if (dist->low_gain > kilo_irlow[0]) {
            dist_low=0;
        } else {
            for(i=1; i<14; i++) {
     e6e:	f5 e0       	ldi	r31, 0x05	; 5
     e70:	3f 2e       	mov	r3, r31
                if(dist->low_gain > kilo_irlow[i]) {
     e72:	e5 e0       	ldi	r30, 0x05	; 5
     e74:	f0 e0       	ldi	r31, 0x00	; 0
            }

            if(index_low == 255) {
                dist_low=90;
            } else {
                double slope=(kilo_irlow[index_low]-kilo_irlow[index_low-1])/0.5;
     e76:	ee 0f       	add	r30, r30
     e78:	ff 1f       	adc	r31, r31
     e7a:	e6 5c       	subi	r30, 0xC6	; 198
     e7c:	fe 4f       	sbci	r31, 0xFE	; 254
     e7e:	80 81       	ld	r24, Z
     e80:	91 81       	ldd	r25, Z+1	; 0x01
     e82:	b8 01       	movw	r22, r16
     e84:	68 1b       	sub	r22, r24
     e86:	79 0b       	sbc	r23, r25
     e88:	80 e0       	ldi	r24, 0x00	; 0
     e8a:	90 e0       	ldi	r25, 0x00	; 0
     e8c:	0e 94 bd 0d 	call	0x1b7a	; 0x1b7a <__floatunsisf>
     e90:	9b 01       	movw	r18, r22
     e92:	ac 01       	movw	r20, r24
     e94:	0e 94 a9 0c 	call	0x1952	; 0x1952 <__addsf3>
     e98:	4b 01       	movw	r8, r22
     e9a:	5c 01       	movw	r10, r24
                double b=(double)kilo_irlow[index_low]-(double)slope*((double)index_low*(double)0.5+(double)0.0);
                b=(((((double)dist->low_gain-(double)b)*(double)10)));
     e9c:	b6 01       	movw	r22, r12
     e9e:	dd 0c       	add	r13, r13
     ea0:	88 0b       	sbc	r24, r24
     ea2:	99 0b       	sbc	r25, r25
     ea4:	0e 94 bf 0d 	call	0x1b7e	; 0x1b7e <__floatsisf>
     ea8:	2b 01       	movw	r4, r22
     eaa:	3c 01       	movw	r6, r24
     eac:	b8 01       	movw	r22, r16
     eae:	80 e0       	ldi	r24, 0x00	; 0
     eb0:	90 e0       	ldi	r25, 0x00	; 0
     eb2:	0e 94 bd 0d 	call	0x1b7a	; 0x1b7a <__floatunsisf>
     eb6:	6b 01       	movw	r12, r22
     eb8:	7c 01       	movw	r14, r24
     eba:	63 2d       	mov	r22, r3
     ebc:	70 e0       	ldi	r23, 0x00	; 0
     ebe:	80 e0       	ldi	r24, 0x00	; 0
     ec0:	90 e0       	ldi	r25, 0x00	; 0
     ec2:	0e 94 bd 0d 	call	0x1b7a	; 0x1b7a <__floatunsisf>
     ec6:	20 e0       	ldi	r18, 0x00	; 0
     ec8:	30 e0       	ldi	r19, 0x00	; 0
     eca:	40 e0       	ldi	r20, 0x00	; 0
     ecc:	5f e3       	ldi	r21, 0x3F	; 63
     ece:	0e 94 4b 0e 	call	0x1c96	; 0x1c96 <__mulsf3>
     ed2:	20 e0       	ldi	r18, 0x00	; 0
     ed4:	30 e0       	ldi	r19, 0x00	; 0
     ed6:	a9 01       	movw	r20, r18
     ed8:	0e 94 a9 0c 	call	0x1952	; 0x1952 <__addsf3>
     edc:	a5 01       	movw	r20, r10
     ede:	94 01       	movw	r18, r8
     ee0:	0e 94 4b 0e 	call	0x1c96	; 0x1c96 <__mulsf3>
     ee4:	9b 01       	movw	r18, r22
     ee6:	ac 01       	movw	r20, r24
     ee8:	c7 01       	movw	r24, r14
     eea:	b6 01       	movw	r22, r12
     eec:	0e 94 a8 0c 	call	0x1950	; 0x1950 <__subsf3>
     ef0:	9b 01       	movw	r18, r22
     ef2:	ac 01       	movw	r20, r24
     ef4:	c3 01       	movw	r24, r6
     ef6:	b2 01       	movw	r22, r4
     ef8:	0e 94 a8 0c 	call	0x1950	; 0x1950 <__subsf3>
                b=((int)((int)b/(int)slope));
                dist_low=b;
     efc:	20 e0       	ldi	r18, 0x00	; 0
     efe:	30 e0       	ldi	r19, 0x00	; 0
     f00:	40 e2       	ldi	r20, 0x20	; 32
     f02:	51 e4       	ldi	r21, 0x41	; 65
     f04:	0e 94 4b 0e 	call	0x1c96	; 0x1c96 <__mulsf3>
     f08:	0e 94 87 0d 	call	0x1b0e	; 0x1b0e <__fixsfsi>
     f0c:	8b 01       	movw	r16, r22
     f0e:	c5 01       	movw	r24, r10
     f10:	b4 01       	movw	r22, r8
     f12:	0e 94 87 0d 	call	0x1b0e	; 0x1b0e <__fixsfsi>
     f16:	ab 01       	movw	r20, r22
     f18:	bc 01       	movw	r22, r24
     f1a:	c8 01       	movw	r24, r16
     f1c:	ba 01       	movw	r22, r20
     f1e:	0e 94 6b 0c 	call	0x18d6	; 0x18d6 <__divmodhi4>
     f22:	16 2f       	mov	r17, r22
            }
        }
    }

    if (dist_low != 255) {
     f24:	6f 3f       	cpi	r22, 0xFF	; 255
     f26:	09 f0       	breq	.+2      	; 0xf2a <estimate_distance+0x472>
     f28:	2c cf       	rjmp	.-424    	; 0xd82 <estimate_distance+0x2ca>
     f2a:	84 cf       	rjmp	.-248    	; 0xe34 <estimate_distance+0x37c>

    if (dist->high_gain < 900) {
        if (dist->high_gain > kilo_irhigh[0]) {
            dist_high=0;
        } else {
            for (i=1; i<14; i++) {
     f2c:	65 e0       	ldi	r22, 0x05	; 5
                if (dist->high_gain > kilo_irhigh[i]) {
     f2e:	85 e0       	ldi	r24, 0x05	; 5
     f30:	90 e0       	ldi	r25, 0x00	; 0
     f32:	7c 01       	movw	r14, r24
     f34:	f1 e0       	ldi	r31, 0x01	; 1
     f36:	ef 1a       	sub	r14, r31
     f38:	f1 08       	sbc	r15, r1
     f3a:	70 e0       	ldi	r23, 0x00	; 0
     f3c:	80 e0       	ldi	r24, 0x00	; 0
     f3e:	90 e0       	ldi	r25, 0x00	; 0
     f40:	0e 94 bd 0d 	call	0x1b7a	; 0x1b7a <__floatunsisf>
     f44:	20 e0       	ldi	r18, 0x00	; 0
     f46:	30 e0       	ldi	r19, 0x00	; 0
     f48:	40 e0       	ldi	r20, 0x00	; 0
     f4a:	5f e3       	ldi	r21, 0x3F	; 63
     f4c:	0e 94 4b 0e 	call	0x1c96	; 0x1c96 <__mulsf3>
     f50:	20 e0       	ldi	r18, 0x00	; 0
     f52:	30 e0       	ldi	r19, 0x00	; 0
     f54:	a9 01       	movw	r20, r18
     f56:	0e 94 a9 0c 	call	0x1952	; 0x1952 <__addsf3>
     f5a:	69 83       	std	Y+1, r22	; 0x01
     f5c:	7a 83       	std	Y+2, r23	; 0x02
     f5e:	8b 83       	std	Y+3, r24	; 0x03
     f60:	9c 83       	std	Y+4, r25	; 0x04
     f62:	49 ce       	rjmp	.-878    	; 0xbf6 <estimate_distance+0x13e>
     f64:	61 e0       	ldi	r22, 0x01	; 1
     f66:	81 e0       	ldi	r24, 0x01	; 1
     f68:	90 e0       	ldi	r25, 0x00	; 0
     f6a:	e3 cf       	rjmp	.-58     	; 0xf32 <estimate_distance+0x47a>
    if (dist->high_gain > 700) {
        if (dist->low_gain > kilo_irlow[0]) {
            dist_low=0;
        } else {
            for(i=1; i<14; i++) {
                if(dist->low_gain > kilo_irlow[i]) {
     f6c:	33 24       	eor	r3, r3
     f6e:	33 94       	inc	r3
     f70:	e1 e0       	ldi	r30, 0x01	; 1
     f72:	f0 e0       	ldi	r31, 0x00	; 0
     f74:	80 cf       	rjmp	.-256    	; 0xe76 <estimate_distance+0x3be>

    if (dist->high_gain > 700) {
        if (dist->low_gain > kilo_irlow[0]) {
            dist_low=0;
        } else {
            for(i=1; i<14; i++) {
     f76:	82 e0       	ldi	r24, 0x02	; 2
     f78:	38 2e       	mov	r3, r24
                if(dist->low_gain > kilo_irlow[i]) {
     f7a:	e2 e0       	ldi	r30, 0x02	; 2
     f7c:	f0 e0       	ldi	r31, 0x00	; 0
     f7e:	7b cf       	rjmp	.-266    	; 0xe76 <estimate_distance+0x3be>

    if (dist->high_gain < 900) {
        if (dist->high_gain > kilo_irhigh[0]) {
            dist_high=0;
        } else {
            for (i=1; i<14; i++) {
     f80:	62 e0       	ldi	r22, 0x02	; 2
                if (dist->high_gain > kilo_irhigh[i]) {
     f82:	82 e0       	ldi	r24, 0x02	; 2
     f84:	90 e0       	ldi	r25, 0x00	; 0
     f86:	d5 cf       	rjmp	.-86     	; 0xf32 <estimate_distance+0x47a>

    if (dist->high_gain < 900) {
        if (dist->high_gain > kilo_irhigh[0]) {
            dist_high=0;
        } else {
            for (i=1; i<14; i++) {
     f88:	63 e0       	ldi	r22, 0x03	; 3
                if (dist->high_gain > kilo_irhigh[i]) {
     f8a:	83 e0       	ldi	r24, 0x03	; 3
     f8c:	90 e0       	ldi	r25, 0x00	; 0
     f8e:	d1 cf       	rjmp	.-94     	; 0xf32 <estimate_distance+0x47a>

    if (dist->high_gain > 700) {
        if (dist->low_gain > kilo_irlow[0]) {
            dist_low=0;
        } else {
            for(i=1; i<14; i++) {
     f90:	b3 e0       	ldi	r27, 0x03	; 3
     f92:	3b 2e       	mov	r3, r27
                if(dist->low_gain > kilo_irlow[i]) {
     f94:	e3 e0       	ldi	r30, 0x03	; 3
     f96:	f0 e0       	ldi	r31, 0x00	; 0
     f98:	6e cf       	rjmp	.-292    	; 0xe76 <estimate_distance+0x3be>

    if (dist->high_gain < 900) {
        if (dist->high_gain > kilo_irhigh[0]) {
            dist_high=0;
        } else {
            for (i=1; i<14; i++) {
     f9a:	64 e0       	ldi	r22, 0x04	; 4
                if (dist->high_gain > kilo_irhigh[i]) {
     f9c:	84 e0       	ldi	r24, 0x04	; 4
     f9e:	90 e0       	ldi	r25, 0x00	; 0
     fa0:	c8 cf       	rjmp	.-112    	; 0xf32 <estimate_distance+0x47a>

    if (dist->high_gain > 700) {
        if (dist->low_gain > kilo_irlow[0]) {
            dist_low=0;
        } else {
            for(i=1; i<14; i++) {
     fa2:	a4 e0       	ldi	r26, 0x04	; 4
     fa4:	3a 2e       	mov	r3, r26
                if(dist->low_gain > kilo_irlow[i]) {
     fa6:	e4 e0       	ldi	r30, 0x04	; 4
     fa8:	f0 e0       	ldi	r31, 0x00	; 0
     faa:	65 cf       	rjmp	.-310    	; 0xe76 <estimate_distance+0x3be>

    if (dist->high_gain < 900) {
        if (dist->high_gain > kilo_irhigh[0]) {
            dist_high=0;
        } else {
            for (i=1; i<14; i++) {
     fac:	66 e0       	ldi	r22, 0x06	; 6
                if (dist->high_gain > kilo_irhigh[i]) {
     fae:	86 e0       	ldi	r24, 0x06	; 6
     fb0:	90 e0       	ldi	r25, 0x00	; 0
     fb2:	bf cf       	rjmp	.-130    	; 0xf32 <estimate_distance+0x47a>

    if (dist->high_gain > 700) {
        if (dist->low_gain > kilo_irlow[0]) {
            dist_low=0;
        } else {
            for(i=1; i<14; i++) {
     fb4:	e6 e0       	ldi	r30, 0x06	; 6
     fb6:	3e 2e       	mov	r3, r30
                if(dist->low_gain > kilo_irlow[i]) {
     fb8:	e6 e0       	ldi	r30, 0x06	; 6
     fba:	f0 e0       	ldi	r31, 0x00	; 0
     fbc:	5c cf       	rjmp	.-328    	; 0xe76 <estimate_distance+0x3be>

    if (dist->high_gain < 900) {
        if (dist->high_gain > kilo_irhigh[0]) {
            dist_high=0;
        } else {
            for (i=1; i<14; i++) {
     fbe:	67 e0       	ldi	r22, 0x07	; 7
                if (dist->high_gain > kilo_irhigh[i]) {
     fc0:	87 e0       	ldi	r24, 0x07	; 7
     fc2:	90 e0       	ldi	r25, 0x00	; 0
     fc4:	b6 cf       	rjmp	.-148    	; 0xf32 <estimate_distance+0x47a>

    if (dist->high_gain > 700) {
        if (dist->low_gain > kilo_irlow[0]) {
            dist_low=0;
        } else {
            for(i=1; i<14; i++) {
     fc6:	77 e0       	ldi	r23, 0x07	; 7
     fc8:	37 2e       	mov	r3, r23
                if(dist->low_gain > kilo_irlow[i]) {
     fca:	e7 e0       	ldi	r30, 0x07	; 7
     fcc:	f0 e0       	ldi	r31, 0x00	; 0
     fce:	53 cf       	rjmp	.-346    	; 0xe76 <estimate_distance+0x3be>

    if (dist->high_gain > 700) {
        if (dist->low_gain > kilo_irlow[0]) {
            dist_low=0;
        } else {
            for(i=1; i<14; i++) {
     fd0:	68 e0       	ldi	r22, 0x08	; 8
     fd2:	36 2e       	mov	r3, r22
                if(dist->low_gain > kilo_irlow[i]) {
     fd4:	e8 e0       	ldi	r30, 0x08	; 8
     fd6:	f0 e0       	ldi	r31, 0x00	; 0
     fd8:	4e cf       	rjmp	.-356    	; 0xe76 <estimate_distance+0x3be>

    if (dist->high_gain < 900) {
        if (dist->high_gain > kilo_irhigh[0]) {
            dist_high=0;
        } else {
            for (i=1; i<14; i++) {
     fda:	68 e0       	ldi	r22, 0x08	; 8
                if (dist->high_gain > kilo_irhigh[i]) {
     fdc:	88 e0       	ldi	r24, 0x08	; 8
     fde:	90 e0       	ldi	r25, 0x00	; 0
     fe0:	a8 cf       	rjmp	.-176    	; 0xf32 <estimate_distance+0x47a>

    if (dist->high_gain > 700) {
        if (dist->low_gain > kilo_irlow[0]) {
            dist_low=0;
        } else {
            for(i=1; i<14; i++) {
     fe2:	59 e0       	ldi	r21, 0x09	; 9
     fe4:	35 2e       	mov	r3, r21
                if(dist->low_gain > kilo_irlow[i]) {
     fe6:	e9 e0       	ldi	r30, 0x09	; 9
     fe8:	f0 e0       	ldi	r31, 0x00	; 0
     fea:	45 cf       	rjmp	.-374    	; 0xe76 <estimate_distance+0x3be>

    if (dist->high_gain < 900) {
        if (dist->high_gain > kilo_irhigh[0]) {
            dist_high=0;
        } else {
            for (i=1; i<14; i++) {
     fec:	69 e0       	ldi	r22, 0x09	; 9
                if (dist->high_gain > kilo_irhigh[i]) {
     fee:	89 e0       	ldi	r24, 0x09	; 9
     ff0:	90 e0       	ldi	r25, 0x00	; 0
     ff2:	9f cf       	rjmp	.-194    	; 0xf32 <estimate_distance+0x47a>

    if (dist->high_gain < 900) {
        if (dist->high_gain > kilo_irhigh[0]) {
            dist_high=0;
        } else {
            for (i=1; i<14; i++) {
     ff4:	6a e0       	ldi	r22, 0x0A	; 10
                if (dist->high_gain > kilo_irhigh[i]) {
     ff6:	8a e0       	ldi	r24, 0x0A	; 10
     ff8:	90 e0       	ldi	r25, 0x00	; 0
     ffa:	9b cf       	rjmp	.-202    	; 0xf32 <estimate_distance+0x47a>

    if (dist->high_gain > 700) {
        if (dist->low_gain > kilo_irlow[0]) {
            dist_low=0;
        } else {
            for(i=1; i<14; i++) {
     ffc:	4a e0       	ldi	r20, 0x0A	; 10
     ffe:	34 2e       	mov	r3, r20
                if(dist->low_gain > kilo_irlow[i]) {
    1000:	ea e0       	ldi	r30, 0x0A	; 10
    1002:	f0 e0       	ldi	r31, 0x00	; 0
    1004:	38 cf       	rjmp	.-400    	; 0xe76 <estimate_distance+0x3be>

    if (dist->high_gain < 900) {
        if (dist->high_gain > kilo_irhigh[0]) {
            dist_high=0;
        } else {
            for (i=1; i<14; i++) {
    1006:	6b e0       	ldi	r22, 0x0B	; 11
                if (dist->high_gain > kilo_irhigh[i]) {
    1008:	8b e0       	ldi	r24, 0x0B	; 11
    100a:	90 e0       	ldi	r25, 0x00	; 0
    100c:	92 cf       	rjmp	.-220    	; 0xf32 <estimate_distance+0x47a>

    if (dist->high_gain > 700) {
        if (dist->low_gain > kilo_irlow[0]) {
            dist_low=0;
        } else {
            for(i=1; i<14; i++) {
    100e:	3b e0       	ldi	r19, 0x0B	; 11
    1010:	33 2e       	mov	r3, r19
                if(dist->low_gain > kilo_irlow[i]) {
    1012:	eb e0       	ldi	r30, 0x0B	; 11
    1014:	f0 e0       	ldi	r31, 0x00	; 0
    1016:	2f cf       	rjmp	.-418    	; 0xe76 <estimate_distance+0x3be>

    if (dist->high_gain < 900) {
        if (dist->high_gain > kilo_irhigh[0]) {
            dist_high=0;
        } else {
            for (i=1; i<14; i++) {
    1018:	6c e0       	ldi	r22, 0x0C	; 12
                if (dist->high_gain > kilo_irhigh[i]) {
    101a:	8c e0       	ldi	r24, 0x0C	; 12
    101c:	90 e0       	ldi	r25, 0x00	; 0
    101e:	89 cf       	rjmp	.-238    	; 0xf32 <estimate_distance+0x47a>

    if (dist->high_gain > 700) {
        if (dist->low_gain > kilo_irlow[0]) {
            dist_low=0;
        } else {
            for(i=1; i<14; i++) {
    1020:	2c e0       	ldi	r18, 0x0C	; 12
    1022:	32 2e       	mov	r3, r18
                if(dist->low_gain > kilo_irlow[i]) {
    1024:	ec e0       	ldi	r30, 0x0C	; 12
    1026:	f0 e0       	ldi	r31, 0x00	; 0
    1028:	26 cf       	rjmp	.-436    	; 0xe76 <estimate_distance+0x3be>

    if (dist->high_gain < 900) {
        if (dist->high_gain > kilo_irhigh[0]) {
            dist_high=0;
        } else {
            for (i=1; i<14; i++) {
    102a:	6d e0       	ldi	r22, 0x0D	; 13
                if (dist->high_gain > kilo_irhigh[i]) {
    102c:	8d e0       	ldi	r24, 0x0D	; 13
    102e:	90 e0       	ldi	r25, 0x00	; 0
    1030:	80 cf       	rjmp	.-256    	; 0xf32 <estimate_distance+0x47a>

    if (dist->high_gain > 700) {
        if (dist->low_gain > kilo_irlow[0]) {
            dist_low=0;
        } else {
            for(i=1; i<14; i++) {
    1032:	9d e0       	ldi	r25, 0x0D	; 13
    1034:	39 2e       	mov	r3, r25
                if(dist->low_gain > kilo_irlow[i]) {
    1036:	ed e0       	ldi	r30, 0x0D	; 13
    1038:	f0 e0       	ldi	r31, 0x00	; 0
    103a:	1d cf       	rjmp	.-454    	; 0xe76 <estimate_distance+0x3be>
    103c:	81 e2       	ldi	r24, 0x21	; 33
    103e:	81 0f       	add	r24, r17
    1040:	fb ce       	rjmp	.-522    	; 0xe38 <estimate_distance+0x380>
            dist_high=b;
        }
    }

    if (dist->high_gain > 700) {
        if (dist->low_gain > kilo_irlow[0]) {
    1042:	d1 01       	movw	r26, r2
    1044:	cd 90       	ld	r12, X+
    1046:	dc 90       	ld	r13, X
    1048:	80 91 3c 01 	lds	r24, 0x013C	; 0x80013c <kilo_irlow>
    104c:	90 91 3d 01 	lds	r25, 0x013D	; 0x80013d <kilo_irlow+0x1>
    1050:	8c 15       	cp	r24, r12
    1052:	9d 05       	cpc	r25, r13
    1054:	08 f0       	brcs	.+2      	; 0x1058 <estimate_distance+0x5a0>
    1056:	2c ce       	rjmp	.-936    	; 0xcb0 <estimate_distance+0x1f8>
            dist_low=0;
    1058:	10 e0       	ldi	r17, 0x00	; 0
    105a:	93 ce       	rjmp	.-730    	; 0xd82 <estimate_distance+0x2ca>

0000105c <__vector_14>:

/**
 * Timer0 interrupt.
 * Used to send messages every kilo_tx_period ticks.
 */
ISR(TIMER0_COMPA_vect) {
    105c:	1f 92       	push	r1
    105e:	0f 92       	push	r0
    1060:	0f b6       	in	r0, 0x3f	; 63
    1062:	0f 92       	push	r0
    1064:	11 24       	eor	r1, r1
    1066:	2f 93       	push	r18
    1068:	3f 93       	push	r19
    106a:	4f 93       	push	r20
    106c:	5f 93       	push	r21
    106e:	6f 93       	push	r22
    1070:	7f 93       	push	r23
    1072:	8f 93       	push	r24
    1074:	9f 93       	push	r25
    1076:	af 93       	push	r26
    1078:	bf 93       	push	r27
    107a:	ef 93       	push	r30
    107c:	ff 93       	push	r31
    tx_clock += tx_increment;
    107e:	20 91 5b 01 	lds	r18, 0x015B	; 0x80015b <tx_clock>
    1082:	30 91 5c 01 	lds	r19, 0x015C	; 0x80015c <tx_clock+0x1>
    1086:	80 91 59 01 	lds	r24, 0x0159	; 0x800159 <tx_increment>
    108a:	90 91 5a 01 	lds	r25, 0x015A	; 0x80015a <tx_increment+0x1>
    108e:	82 0f       	add	r24, r18
    1090:	93 1f       	adc	r25, r19
    1092:	90 93 5c 01 	sts	0x015C, r25	; 0x80015c <tx_clock+0x1>
    1096:	80 93 5b 01 	sts	0x015B, r24	; 0x80015b <tx_clock>
    tx_increment = 0xFF;
    109a:	8f ef       	ldi	r24, 0xFF	; 255
    109c:	90 e0       	ldi	r25, 0x00	; 0
    109e:	90 93 5a 01 	sts	0x015A, r25	; 0x80015a <tx_increment+0x1>
    10a2:	80 93 59 01 	sts	0x0159, r24	; 0x800159 <tx_increment>
    OCR0A = tx_increment;
    10a6:	8f ef       	ldi	r24, 0xFF	; 255
    10a8:	87 bd       	out	0x27, r24	; 39
    kilo_ticks++;
    10aa:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <kilo_ticks>
    10ae:	90 91 38 01 	lds	r25, 0x0138	; 0x800138 <kilo_ticks+0x1>
    10b2:	a0 91 39 01 	lds	r26, 0x0139	; 0x800139 <kilo_ticks+0x2>
    10b6:	b0 91 3a 01 	lds	r27, 0x013A	; 0x80013a <kilo_ticks+0x3>
    10ba:	01 96       	adiw	r24, 0x01	; 1
    10bc:	a1 1d       	adc	r26, r1
    10be:	b1 1d       	adc	r27, r1
    10c0:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <kilo_ticks>
    10c4:	90 93 38 01 	sts	0x0138, r25	; 0x800138 <kilo_ticks+0x1>
    10c8:	a0 93 39 01 	sts	0x0139, r26	; 0x800139 <kilo_ticks+0x2>
    10cc:	b0 93 3a 01 	sts	0x013A, r27	; 0x80013a <kilo_ticks+0x3>

    // Increments counter_ticks_for_voltage by 1 tick until 255
    if(kilo_state == RUNNING && counter_ticks_for_voltage < 255)
    10d0:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <kilo_state>
    10d4:	84 30       	cpi	r24, 0x04	; 4
    10d6:	21 f1       	breq	.+72     	; 0x1120 <__vector_14+0xc4>
        counter_ticks_for_voltage++;

    if(!rx_busy && tx_clock>kilo_tx_period && kilo_state == RUNNING) {
    10d8:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <rx_busy>
    10dc:	81 11       	cpse	r24, r1
    10de:	0f c0       	rjmp	.+30     	; 0x10fe <__vector_14+0xa2>
    10e0:	80 91 6a 01 	lds	r24, 0x016A	; 0x80016a <kilo_tx_period>
    10e4:	90 91 6b 01 	lds	r25, 0x016B	; 0x80016b <kilo_tx_period+0x1>
    10e8:	20 91 5b 01 	lds	r18, 0x015B	; 0x80015b <tx_clock>
    10ec:	30 91 5c 01 	lds	r19, 0x015C	; 0x80015c <tx_clock+0x1>
    10f0:	82 17       	cp	r24, r18
    10f2:	93 07       	cpc	r25, r19
    10f4:	20 f4       	brcc	.+8      	; 0x10fe <__vector_14+0xa2>
    10f6:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <kilo_state>
    10fa:	84 30       	cpi	r24, 0x04	; 4
    10fc:	c9 f0       	breq	.+50     	; 0x1130 <__vector_14+0xd4>
                tx_increment = rand()&0xFF;
                OCR0A = tx_increment;
            }
        }
    }
}
    10fe:	ff 91       	pop	r31
    1100:	ef 91       	pop	r30
    1102:	bf 91       	pop	r27
    1104:	af 91       	pop	r26
    1106:	9f 91       	pop	r25
    1108:	8f 91       	pop	r24
    110a:	7f 91       	pop	r23
    110c:	6f 91       	pop	r22
    110e:	5f 91       	pop	r21
    1110:	4f 91       	pop	r20
    1112:	3f 91       	pop	r19
    1114:	2f 91       	pop	r18
    1116:	0f 90       	pop	r0
    1118:	0f be       	out	0x3f, r0	; 63
    111a:	0f 90       	pop	r0
    111c:	1f 90       	pop	r1
    111e:	18 95       	reti
    tx_increment = 0xFF;
    OCR0A = tx_increment;
    kilo_ticks++;

    // Increments counter_ticks_for_voltage by 1 tick until 255
    if(kilo_state == RUNNING && counter_ticks_for_voltage < 255)
    1120:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <__data_end>
    1124:	8f 3f       	cpi	r24, 0xFF	; 255
    1126:	c1 f2       	breq	.-80     	; 0x10d8 <__vector_14+0x7c>
        counter_ticks_for_voltage++;
    1128:	8f 5f       	subi	r24, 0xFF	; 255
    112a:	80 93 0e 01 	sts	0x010E, r24	; 0x80010e <__data_end>
    112e:	d4 cf       	rjmp	.-88     	; 0x10d8 <__vector_14+0x7c>

    if(!rx_busy && tx_clock>kilo_tx_period && kilo_state == RUNNING) {
        message_t *msg = kilo_message_tx();
    1130:	e0 91 05 01 	lds	r30, 0x0105	; 0x800105 <kilo_message_tx>
    1134:	f0 91 06 01 	lds	r31, 0x0106	; 0x800106 <kilo_message_tx+0x1>
    1138:	09 95       	icall
        if (msg) {
    113a:	00 97       	sbiw	r24, 0x00	; 0
    113c:	01 f3       	breq	.-64     	; 0x10fe <__vector_14+0xa2>
            if (message_send(msg)) {
    113e:	0e 94 dd 0b 	call	0x17ba	; 0x17ba <message_send>
    1142:	81 11       	cpse	r24, r1
    1144:	0a c0       	rjmp	.+20     	; 0x115a <__vector_14+0xfe>
                kilo_message_tx_success();
                tx_clock = 0;
            } else {
                tx_increment = rand()&0xFF;
    1146:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <rand>
    114a:	9c 01       	movw	r18, r24
    114c:	33 27       	eor	r19, r19
    114e:	30 93 5a 01 	sts	0x015A, r19	; 0x80015a <tx_increment+0x1>
    1152:	20 93 59 01 	sts	0x0159, r18	; 0x800159 <tx_increment>
                OCR0A = tx_increment;
    1156:	87 bd       	out	0x27, r24	; 39
            }
        }
    }
}
    1158:	d2 cf       	rjmp	.-92     	; 0x10fe <__vector_14+0xa2>

    if(!rx_busy && tx_clock>kilo_tx_period && kilo_state == RUNNING) {
        message_t *msg = kilo_message_tx();
        if (msg) {
            if (message_send(msg)) {
                kilo_message_tx_success();
    115a:	e0 91 03 01 	lds	r30, 0x0103	; 0x800103 <kilo_message_tx_success>
    115e:	f0 91 04 01 	lds	r31, 0x0104	; 0x800104 <kilo_message_tx_success+0x1>
    1162:	09 95       	icall
                tx_clock = 0;
    1164:	10 92 5c 01 	sts	0x015C, r1	; 0x80015c <tx_clock+0x1>
    1168:	10 92 5b 01 	sts	0x015B, r1	; 0x80015b <tx_clock>
    116c:	c8 cf       	rjmp	.-112    	; 0x10fe <__vector_14+0xa2>

0000116e <set_color>:
EMPTY_INTERRUPT(TIMER0_COMPA_vect)

#endif

void set_color(uint8_t rgb) {
    if (rgb&(1<<0))
    116e:	80 ff       	sbrs	r24, 0
    1170:	11 c0       	rjmp	.+34     	; 0x1194 <set_color+0x26>
        DDRD |= (1<<5);
    1172:	55 9a       	sbi	0x0a, 5	; 10
    else
        DDRD &= ~(1<<5);

    if (rgb&(1<<1))
    1174:	81 ff       	sbrs	r24, 1
    1176:	11 c0       	rjmp	.+34     	; 0x119a <set_color+0x2c>
        DDRD |= (1<<4);
    1178:	54 9a       	sbi	0x0a, 4	; 10
    else
        DDRD &= ~(1<<4);

    if (rgb&(1<<2))
    117a:	82 ff       	sbrs	r24, 2
    117c:	11 c0       	rjmp	.+34     	; 0x11a0 <set_color+0x32>
        DDRC |= (1<<3);
    117e:	3b 9a       	sbi	0x07, 3	; 7
    else
        DDRC &= ~(1<<3);

    if (rgb&(1<<3))
    1180:	83 ff       	sbrs	r24, 3
    1182:	11 c0       	rjmp	.+34     	; 0x11a6 <set_color+0x38>
        DDRC |= (1<<2);
    1184:	3a 9a       	sbi	0x07, 2	; 7
    else
        DDRC &= ~(1<<2);

    if (rgb&(1<<4))
    1186:	84 ff       	sbrs	r24, 4
    1188:	11 c0       	rjmp	.+34     	; 0x11ac <set_color+0x3e>
        DDRC |= (1<<5);
    118a:	3d 9a       	sbi	0x07, 5	; 7
    else
        DDRC &= ~(1<<5);

    if (rgb&(1<<5))
    118c:	85 fd       	sbrc	r24, 5
    118e:	11 c0       	rjmp	.+34     	; 0x11b2 <set_color+0x44>
        DDRC |= (1<<4);
    else
        DDRC &= ~(1<<4);
    1190:	3c 98       	cbi	0x07, 4	; 7
    1192:	08 95       	ret

void set_color(uint8_t rgb) {
    if (rgb&(1<<0))
        DDRD |= (1<<5);
    else
        DDRD &= ~(1<<5);
    1194:	55 98       	cbi	0x0a, 5	; 10

    if (rgb&(1<<1))
    1196:	81 fd       	sbrc	r24, 1
    1198:	ef cf       	rjmp	.-34     	; 0x1178 <set_color+0xa>
        DDRD |= (1<<4);
    else
        DDRD &= ~(1<<4);
    119a:	54 98       	cbi	0x0a, 4	; 10

    if (rgb&(1<<2))
    119c:	82 fd       	sbrc	r24, 2
    119e:	ef cf       	rjmp	.-34     	; 0x117e <set_color+0x10>
        DDRC |= (1<<3);
    else
        DDRC &= ~(1<<3);
    11a0:	3b 98       	cbi	0x07, 3	; 7

    if (rgb&(1<<3))
    11a2:	83 fd       	sbrc	r24, 3
    11a4:	ef cf       	rjmp	.-34     	; 0x1184 <set_color+0x16>
        DDRC |= (1<<2);
    else
        DDRC &= ~(1<<2);
    11a6:	3a 98       	cbi	0x07, 2	; 7

    if (rgb&(1<<4))
    11a8:	84 fd       	sbrc	r24, 4
    11aa:	ef cf       	rjmp	.-34     	; 0x118a <set_color+0x1c>
        DDRC |= (1<<5);
    else
        DDRC &= ~(1<<5);
    11ac:	3d 98       	cbi	0x07, 5	; 7

    if (rgb&(1<<5))
    11ae:	85 ff       	sbrs	r24, 5
    11b0:	ef cf       	rjmp	.-34     	; 0x1190 <set_color+0x22>
        DDRC |= (1<<4);
    11b2:	3c 9a       	sbi	0x07, 4	; 7
    11b4:	08 95       	ret

000011b6 <__vector_11>:

/**
 * Timer1 interrupt.
 * Timeout which is trigerred if stop bit is not received.
 */
ISR(TIMER1_COMPA_vect) {
    11b6:	1f 92       	push	r1
    11b8:	0f 92       	push	r0
    11ba:	0f b6       	in	r0, 0x3f	; 63
    11bc:	0f 92       	push	r0
    11be:	11 24       	eor	r1, r1
    11c0:	8f 93       	push	r24
    11c2:	9f 93       	push	r25
    rx_timer_off();
    11c4:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
    11c8:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__DATA_REGION_ORIGIN__+0x25>
    11cc:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__DATA_REGION_ORIGIN__+0x24>
    rx_leadingbit = 1;
    11d0:	81 e0       	ldi	r24, 0x01	; 1
    11d2:	80 93 14 01 	sts	0x0114, r24	; 0x800114 <rx_leadingbit>
    rx_leadingbyte = 1;
    11d6:	80 93 58 01 	sts	0x0158, r24	; 0x800158 <rx_leadingbyte>
    rx_busy = 0;
    11da:	10 92 3b 01 	sts	0x013B, r1	; 0x80013b <rx_busy>
    adc_trigger_high_gain();
    11de:	10 92 7c 00 	sts	0x007C, r1	; 0x80007c <__DATA_REGION_ORIGIN__+0x1c>
    11e2:	93 ea       	ldi	r25, 0xA3	; 163
    11e4:	90 93 7a 00 	sts	0x007A, r25	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    11e8:	80 93 7b 00 	sts	0x007B, r24	; 0x80007b <__DATA_REGION_ORIGIN__+0x1b>
}
    11ec:	9f 91       	pop	r25
    11ee:	8f 91       	pop	r24
    11f0:	0f 90       	pop	r0
    11f2:	0f be       	out	0x3f, r0	; 63
    11f4:	0f 90       	pop	r0
    11f6:	1f 90       	pop	r1
    11f8:	18 95       	reti

000011fa <__vector_23>:

/**
 * Analog comparator trigger interrupt.
 * Triggerred for incoming IR pulses (i.e. individual bits).
 */
ISR(ANALOG_COMP_vect) {
    11fa:	1f 92       	push	r1
    11fc:	0f 92       	push	r0
    11fe:	0f b6       	in	r0, 0x3f	; 63
    1200:	0f 92       	push	r0
    1202:	11 24       	eor	r1, r1
    1204:	2f 93       	push	r18
    1206:	3f 93       	push	r19
    1208:	4f 93       	push	r20
    120a:	5f 93       	push	r21
    120c:	6f 93       	push	r22
    120e:	7f 93       	push	r23
    1210:	8f 93       	push	r24
    1212:	9f 93       	push	r25
    1214:	af 93       	push	r26
    1216:	bf 93       	push	r27
    1218:	cf 93       	push	r28
    121a:	df 93       	push	r29
    121c:	ef 93       	push	r30
    121e:	ff 93       	push	r31
    uint16_t timer = TCNT1;
    1220:	20 91 84 00 	lds	r18, 0x0084	; 0x800084 <__DATA_REGION_ORIGIN__+0x24>
    1224:	30 91 85 00 	lds	r19, 0x0085	; 0x800085 <__DATA_REGION_ORIGIN__+0x25>

    rx_busy = 1;
    1228:	41 e0       	ldi	r20, 0x01	; 1
    122a:	40 93 3b 01 	sts	0x013B, r20	; 0x80013b <rx_busy>
    /* adc_trigger_stop(); */

    if(rx_leadingbit) {       // Start bit received.
    122e:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <rx_leadingbit>
    1232:	88 23       	and	r24, r24
    1234:	a9 f1       	breq	.+106    	; 0x12a0 <__vector_23+0xa6>
        rx_timer_on();
    1236:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__DATA_REGION_ORIGIN__+0x25>
    123a:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__DATA_REGION_ORIGIN__+0x24>
    123e:	40 93 81 00 	sts	0x0081, r20	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
        rx_bytevalue = 0;
    1242:	10 92 6c 01 	sts	0x016C, r1	; 0x80016c <rx_bytevalue>
        rx_leadingbit = 0;
    1246:	10 92 14 01 	sts	0x0114, r1	; 0x800114 <rx_leadingbit>
        if (rx_leadingbyte) {
    124a:	80 91 58 01 	lds	r24, 0x0158	; 0x800158 <rx_leadingbyte>
    124e:	88 23       	and	r24, r24
    1250:	a1 f0       	breq	.+40     	; 0x127a <__vector_23+0x80>
            adc_finish_conversion();
    1252:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    1256:	86 fd       	sbrc	r24, 6
    1258:	fc cf       	rjmp	.-8      	; 0x1252 <__vector_23+0x58>
            rx_dist.high_gain = ADCW;
    125a:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__DATA_REGION_ORIGIN__+0x18>
    125e:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__DATA_REGION_ORIGIN__+0x19>
    1262:	90 93 36 01 	sts	0x0136, r25	; 0x800136 <rx_dist+0x3>
    1266:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <rx_dist+0x2>
            adc_trigger_low_gain();
    126a:	81 e0       	ldi	r24, 0x01	; 1
    126c:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__DATA_REGION_ORIGIN__+0x1c>
    1270:	93 ea       	ldi	r25, 0xA3	; 163
    1272:	90 93 7a 00 	sts	0x007A, r25	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    1276:	80 93 7b 00 	sts	0x007B, r24	; 0x80007b <__DATA_REGION_ORIGIN__+0x1b>
                    }
                }
            }
        }
    }
}
    127a:	ff 91       	pop	r31
    127c:	ef 91       	pop	r30
    127e:	df 91       	pop	r29
    1280:	cf 91       	pop	r28
    1282:	bf 91       	pop	r27
    1284:	af 91       	pop	r26
    1286:	9f 91       	pop	r25
    1288:	8f 91       	pop	r24
    128a:	7f 91       	pop	r23
    128c:	6f 91       	pop	r22
    128e:	5f 91       	pop	r21
    1290:	4f 91       	pop	r20
    1292:	3f 91       	pop	r19
    1294:	2f 91       	pop	r18
    1296:	0f 90       	pop	r0
    1298:	0f be       	out	0x3f, r0	; 63
    129a:	0f 90       	pop	r0
    129c:	1f 90       	pop	r1
    129e:	18 95       	reti
            rx_dist.high_gain = ADCW;
            adc_trigger_low_gain();
        }
    } else {
        // Stray bit received
        if (timer <= rx_bitcycles/2 || timer >= rx_bitcycles*9+rx_bitcycles/2) {
    12a0:	c9 01       	movw	r24, r18
    12a2:	87 58       	subi	r24, 0x87	; 135
    12a4:	91 09       	sbc	r25, r1
    12a6:	84 37       	cpi	r24, 0x74	; 116
    12a8:	99 40       	sbci	r25, 0x09	; 9
    12aa:	08 f0       	brcs	.+2      	; 0x12ae <__vector_23+0xb4>
    12ac:	60 c0       	rjmp	.+192    	; 0x136e <__vector_23+0x174>
            adc_trigger_high_gain();
        } else {
            // NOTE: The following code avoids a division which takes
            // too many clock cycles and throws off the interrupt.
            const uint16_t M = ((1L<<16)+rx_bitcycles-1)/rx_bitcycles;
            uint8_t bitindex = ((uint32_t)(timer-rx_bitcycles/2)*M)>>16;
    12ae:	26 58       	subi	r18, 0x86	; 134
    12b0:	31 09       	sbc	r19, r1
    12b2:	a4 ef       	ldi	r26, 0xF4	; 244
    12b4:	b0 e0       	ldi	r27, 0x00	; 0
    12b6:	0e 94 85 0c 	call	0x190a	; 0x190a <__umulhisi3>
    12ba:	aa 27       	eor	r26, r26
    12bc:	bb 27       	eor	r27, r27
            if (bitindex <= 7) { // Data bit received.
    12be:	88 30       	cpi	r24, 0x08	; 8
    12c0:	08 f4       	brcc	.+2      	; 0x12c4 <__vector_23+0xca>
    12c2:	8c c0       	rjmp	.+280    	; 0x13dc <__vector_23+0x1e2>
                rx_bytevalue |= (1<<bitindex);
            } else {             // Stop bit received.
                rx_leadingbit = 1;
    12c4:	40 93 14 01 	sts	0x0114, r20	; 0x800114 <rx_leadingbit>
                if (rx_leadingbyte) {
    12c8:	80 91 58 01 	lds	r24, 0x0158	; 0x800158 <rx_leadingbyte>
    12cc:	81 11       	cpse	r24, r1
    12ce:	63 c0       	rjmp	.+198    	; 0x1396 <__vector_23+0x19c>
                    } else {                // Leading byte received.
                        rx_leadingbyte = 0;
                        rx_byteindex = 0;
                    }
                } else {
                    rawmsg[rx_byteindex] = rx_bytevalue;
    12d0:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <rx_byteindex>
    12d4:	e8 2f       	mov	r30, r24
    12d6:	f0 e0       	ldi	r31, 0x00	; 0
    12d8:	e2 5a       	subi	r30, 0xA2	; 162
    12da:	fe 4f       	sbci	r31, 0xFE	; 254
    12dc:	90 91 6c 01 	lds	r25, 0x016C	; 0x80016c <rx_bytevalue>
    12e0:	90 83       	st	Z, r25
                    rx_byteindex++;
    12e2:	8f 5f       	subi	r24, 0xFF	; 255
    12e4:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <rx_byteindex>
                    if (rx_byteindex == sizeof(message_t)) {
    12e8:	8c 30       	cpi	r24, 0x0C	; 12
    12ea:	39 f6       	brne	.-114    	; 0x127a <__vector_23+0x80>
                        rx_timer_off();
    12ec:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
    12f0:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__DATA_REGION_ORIGIN__+0x25>
    12f4:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__DATA_REGION_ORIGIN__+0x24>
                        rx_leadingbyte = 1;
    12f8:	40 93 58 01 	sts	0x0158, r20	; 0x800158 <rx_leadingbyte>
                        rx_busy = 0;
    12fc:	10 92 3b 01 	sts	0x013B, r1	; 0x80013b <rx_busy>

                        if (rx_msg.crc == message_crc(&rx_msg))
    1300:	c0 91 68 01 	lds	r28, 0x0168	; 0x800168 <rx_msg+0xa>
    1304:	d0 91 69 01 	lds	r29, 0x0169	; 0x800169 <rx_msg+0xb>
    1308:	8e e5       	ldi	r24, 0x5E	; 94
    130a:	91 e0       	ldi	r25, 0x01	; 1
    130c:	0e 94 24 0b 	call	0x1648	; 0x1648 <message_crc>
    1310:	c8 17       	cp	r28, r24
    1312:	d9 07       	cpc	r29, r25
    1314:	09 f0       	breq	.+2      	; 0x1318 <__vector_23+0x11e>
    1316:	b1 cf       	rjmp	.-158    	; 0x127a <__vector_23+0x80>
}

static inline void process_message() {
    AddressPointer_t reset = (AddressPointer_t)0x0000, bootload = (AddressPointer_t)0x7000;
    calibmsg_t *calibmsg = (calibmsg_t*)&rx_msg.data;
    if (rx_msg.type < BOOT) {
    1318:	80 91 67 01 	lds	r24, 0x0167	; 0x800167 <rx_msg+0x9>
    131c:	87 ff       	sbrs	r24, 7
    131e:	72 c0       	rjmp	.+228    	; 0x1404 <__vector_23+0x20a>
        n_commands_received = 0;
        return;
    }
    
    // Doesn't respond to other signals apart from neighbors while running if a few received
    if(kilo_state == RUNNING && n_commands_received < THRESHOLD_N_COMMANDS){
    1320:	90 91 13 01 	lds	r25, 0x0113	; 0x800113 <kilo_state>
    1324:	94 30       	cpi	r25, 0x04	; 4
    1326:	09 f4       	brne	.+2      	; 0x132a <__vector_23+0x130>
    1328:	7f c0       	rjmp	.+254    	; 0x1428 <__vector_23+0x22e>
        
        return;
    }
    
    // In RUNNING state, it has to receive at least THREHOLD_N_COMMANDS continuous commands to react
    else if( (kilo_state == RUNNING && n_commands_received == THRESHOLD_N_COMMANDS) || (kilo_state != RUNNING)){
    132a:	90 91 13 01 	lds	r25, 0x0113	; 0x800113 <kilo_state>
    132e:	94 30       	cpi	r25, 0x04	; 4
    1330:	09 f4       	brne	.+2      	; 0x1334 <__vector_23+0x13a>
    1332:	74 c0       	rjmp	.+232    	; 0x141c <__vector_23+0x222>
    1334:	90 91 13 01 	lds	r25, 0x0113	; 0x800113 <kilo_state>
    1338:	94 30       	cpi	r25, 0x04	; 4
    133a:	09 f4       	brne	.+2      	; 0x133e <__vector_23+0x144>
    133c:	9e cf       	rjmp	.-196    	; 0x127a <__vector_23+0x80>
    
        n_commands_received = 0;
    133e:	10 92 6f 01 	sts	0x016F, r1	; 0x80016f <n_commands_received>

        if (rx_msg.type != READUID && rx_msg.type != RUN && rx_msg.type != CALIB)
    1342:	98 e7       	ldi	r25, 0x78	; 120
    1344:	98 0f       	add	r25, r24
    1346:	93 30       	cpi	r25, 0x03	; 3
    1348:	30 f0       	brcs	.+12     	; 0x1356 <__vector_23+0x15c>
            motors_off();
    134a:	53 98       	cbi	0x0a, 3	; 10
    134c:	23 98       	cbi	0x04, 3	; 4
    134e:	10 92 b4 00 	sts	0x00B4, r1	; 0x8000b4 <__DATA_REGION_ORIGIN__+0x54>
    1352:	10 92 b3 00 	sts	0x00B3, r1	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
        switch (rx_msg.type) {
    1356:	90 e0       	ldi	r25, 0x00	; 0
    1358:	fc 01       	movw	r30, r24
    135a:	e0 58       	subi	r30, 0x80	; 128
    135c:	f1 09       	sbc	r31, r1
    135e:	eb 30       	cpi	r30, 0x0B	; 11
    1360:	f1 05       	cpc	r31, r1
    1362:	08 f0       	brcs	.+2      	; 0x1366 <__vector_23+0x16c>
    1364:	8a cf       	rjmp	.-236    	; 0x127a <__vector_23+0x80>
    1366:	e5 5c       	subi	r30, 0xC5	; 197
    1368:	ff 4f       	sbci	r31, 0xFF	; 255
    136a:	0c 94 7f 0c 	jmp	0x18fe	; 0x18fe <__tablejump2__>
            adc_trigger_low_gain();
        }
    } else {
        // Stray bit received
        if (timer <= rx_bitcycles/2 || timer >= rx_bitcycles*9+rx_bitcycles/2) {
            rx_timer_off();
    136e:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
    1372:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__DATA_REGION_ORIGIN__+0x25>
    1376:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__DATA_REGION_ORIGIN__+0x24>
            rx_leadingbit = 1;
    137a:	40 93 14 01 	sts	0x0114, r20	; 0x800114 <rx_leadingbit>
            rx_leadingbyte = 1;
    137e:	40 93 58 01 	sts	0x0158, r20	; 0x800158 <rx_leadingbyte>
            rx_busy = 0;
    1382:	10 92 3b 01 	sts	0x013B, r1	; 0x80013b <rx_busy>
            adc_trigger_high_gain();
    1386:	10 92 7c 00 	sts	0x007C, r1	; 0x80007c <__DATA_REGION_ORIGIN__+0x1c>
    138a:	83 ea       	ldi	r24, 0xA3	; 163
    138c:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    1390:	40 93 7b 00 	sts	0x007B, r20	; 0x80007b <__DATA_REGION_ORIGIN__+0x1b>
    1394:	72 cf       	rjmp	.-284    	; 0x127a <__vector_23+0x80>
            if (bitindex <= 7) { // Data bit received.
                rx_bytevalue |= (1<<bitindex);
            } else {             // Stop bit received.
                rx_leadingbit = 1;
                if (rx_leadingbyte) {
                    adc_finish_conversion();
    1396:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    139a:	86 fd       	sbrc	r24, 6
    139c:	fc cf       	rjmp	.-8      	; 0x1396 <__vector_23+0x19c>
                    rx_dist.low_gain = ADCW;
    139e:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__DATA_REGION_ORIGIN__+0x18>
    13a2:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__DATA_REGION_ORIGIN__+0x19>
    13a6:	90 93 34 01 	sts	0x0134, r25	; 0x800134 <rx_dist+0x1>
    13aa:	80 93 33 01 	sts	0x0133, r24	; 0x800133 <rx_dist>
                    adc_trigger_high_gain();
    13ae:	10 92 7c 00 	sts	0x007C, r1	; 0x80007c <__DATA_REGION_ORIGIN__+0x1c>
    13b2:	83 ea       	ldi	r24, 0xA3	; 163
    13b4:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    13b8:	81 e0       	ldi	r24, 0x01	; 1
    13ba:	80 93 7b 00 	sts	0x007B, r24	; 0x80007b <__DATA_REGION_ORIGIN__+0x1b>
                    if (rx_bytevalue != 0) { // Collision detected.
    13be:	90 91 6c 01 	lds	r25, 0x016C	; 0x80016c <rx_bytevalue>
    13c2:	99 23       	and	r25, r25
    13c4:	d1 f0       	breq	.+52     	; 0x13fa <__vector_23+0x200>
                        rx_timer_off();
    13c6:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
    13ca:	10 92 85 00 	sts	0x0085, r1	; 0x800085 <__DATA_REGION_ORIGIN__+0x25>
    13ce:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__DATA_REGION_ORIGIN__+0x24>
                        rx_leadingbyte = 1;
    13d2:	80 93 58 01 	sts	0x0158, r24	; 0x800158 <rx_leadingbyte>
                        rx_busy = 0;
    13d6:	10 92 3b 01 	sts	0x013B, r1	; 0x80013b <rx_busy>
    13da:	4f cf       	rjmp	.-354    	; 0x127a <__vector_23+0x80>
            // NOTE: The following code avoids a division which takes
            // too many clock cycles and throws off the interrupt.
            const uint16_t M = ((1L<<16)+rx_bitcycles-1)/rx_bitcycles;
            uint8_t bitindex = ((uint32_t)(timer-rx_bitcycles/2)*M)>>16;
            if (bitindex <= 7) { // Data bit received.
                rx_bytevalue |= (1<<bitindex);
    13dc:	21 e0       	ldi	r18, 0x01	; 1
    13de:	30 e0       	ldi	r19, 0x00	; 0
    13e0:	f9 01       	movw	r30, r18
    13e2:	02 c0       	rjmp	.+4      	; 0x13e8 <__vector_23+0x1ee>
    13e4:	ee 0f       	add	r30, r30
    13e6:	ff 1f       	adc	r31, r31
    13e8:	8a 95       	dec	r24
    13ea:	e2 f7       	brpl	.-8      	; 0x13e4 <__vector_23+0x1ea>
    13ec:	cf 01       	movw	r24, r30
    13ee:	90 91 6c 01 	lds	r25, 0x016C	; 0x80016c <rx_bytevalue>
    13f2:	89 2b       	or	r24, r25
    13f4:	80 93 6c 01 	sts	0x016C, r24	; 0x80016c <rx_bytevalue>
    13f8:	40 cf       	rjmp	.-384    	; 0x127a <__vector_23+0x80>
                    if (rx_bytevalue != 0) { // Collision detected.
                        rx_timer_off();
                        rx_leadingbyte = 1;
                        rx_busy = 0;
                    } else {                // Leading byte received.
                        rx_leadingbyte = 0;
    13fa:	10 92 58 01 	sts	0x0158, r1	; 0x800158 <rx_leadingbyte>
                        rx_byteindex = 0;
    13fe:	10 92 32 01 	sts	0x0132, r1	; 0x800132 <rx_byteindex>
    1402:	3b cf       	rjmp	.-394    	; 0x127a <__vector_23+0x80>

static inline void process_message() {
    AddressPointer_t reset = (AddressPointer_t)0x0000, bootload = (AddressPointer_t)0x7000;
    calibmsg_t *calibmsg = (calibmsg_t*)&rx_msg.data;
    if (rx_msg.type < BOOT) {
        kilo_message_rx(&rx_msg, &rx_dist);
    1404:	e0 91 07 01 	lds	r30, 0x0107	; 0x800107 <kilo_message_rx>
    1408:	f0 91 08 01 	lds	r31, 0x0108	; 0x800108 <kilo_message_rx+0x1>
    140c:	63 e3       	ldi	r22, 0x33	; 51
    140e:	71 e0       	ldi	r23, 0x01	; 1
    1410:	8e e5       	ldi	r24, 0x5E	; 94
    1412:	91 e0       	ldi	r25, 0x01	; 1
    1414:	09 95       	icall
        
        n_commands_received = 0;
    1416:	10 92 6f 01 	sts	0x016F, r1	; 0x80016f <n_commands_received>
    141a:	2f cf       	rjmp	.-418    	; 0x127a <__vector_23+0x80>
        
        return;
    }
    
    // In RUNNING state, it has to receive at least THREHOLD_N_COMMANDS continuous commands to react
    else if( (kilo_state == RUNNING && n_commands_received == THRESHOLD_N_COMMANDS) || (kilo_state != RUNNING)){
    141c:	90 91 6f 01 	lds	r25, 0x016F	; 0x80016f <n_commands_received>
    1420:	9a 30       	cpi	r25, 0x0A	; 10
    1422:	09 f0       	breq	.+2      	; 0x1426 <__vector_23+0x22c>
    1424:	87 cf       	rjmp	.-242    	; 0x1334 <__vector_23+0x13a>
    1426:	8b cf       	rjmp	.-234    	; 0x133e <__vector_23+0x144>
        n_commands_received = 0;
        return;
    }
    
    // Doesn't respond to other signals apart from neighbors while running if a few received
    if(kilo_state == RUNNING && n_commands_received < THRESHOLD_N_COMMANDS){
    1428:	90 91 6f 01 	lds	r25, 0x016F	; 0x80016f <n_commands_received>
    142c:	9a 30       	cpi	r25, 0x0A	; 10
    142e:	08 f0       	brcs	.+2      	; 0x1432 <__vector_23+0x238>
    1430:	7c cf       	rjmp	.-264    	; 0x132a <__vector_23+0x130>
    
        n_commands_received++;
    1432:	9f 5f       	subi	r25, 0xFF	; 255
    1434:	90 93 6f 01 	sts	0x016F, r25	; 0x80016f <n_commands_received>
    1438:	20 cf       	rjmp	.-448    	; 0x127a <__vector_23+0x80>
                    motors_on();
                    kilo_state = SETUP;
                }
                break;
            case CALIB:
                switch(calibmsg->mode) {
    143a:	80 91 5e 01 	lds	r24, 0x015E	; 0x80015e <rx_msg>
    143e:	82 30       	cpi	r24, 0x02	; 2
    1440:	09 f4       	brne	.+2      	; 0x1444 <__vector_23+0x24a>
    1442:	cd c0       	rjmp	.+410    	; 0x15de <__vector_23+0x3e4>
    1444:	08 f0       	brcs	.+2      	; 0x1448 <__vector_23+0x24e>
    1446:	b5 c0       	rjmp	.+362    	; 0x15b2 <__vector_23+0x3b8>
    1448:	88 23       	and	r24, r24
    144a:	09 f4       	brne	.+2      	; 0x144e <__vector_23+0x254>
    144c:	7b c0       	rjmp	.+246    	; 0x1544 <__vector_23+0x34a>
    144e:	81 30       	cpi	r24, 0x01	; 1
    1450:	09 f0       	breq	.+2      	; 0x1454 <__vector_23+0x25a>
    1452:	ac c0       	rjmp	.+344    	; 0x15ac <__vector_23+0x3b2>
                            motors_off();
                            kilo_state = IDLE;
                        }
                        break;
                    case CALIB_UID:
                        kilo_uid = calibmsg->uid;
    1454:	80 91 5f 01 	lds	r24, 0x015F	; 0x80015f <rx_msg+0x1>
    1458:	90 91 60 01 	lds	r25, 0x0160	; 0x800160 <rx_msg+0x2>
    145c:	90 93 6e 01 	sts	0x016E, r25	; 0x80016e <kilo_uid+0x1>
    1460:	80 93 6d 01 	sts	0x016D, r24	; 0x80016d <kilo_uid>
                        cur_motion = MOVE_STOP;
    1464:	10 92 11 01 	sts	0x0111, r1	; 0x800111 <cur_motion>
                            kilo_straight_left = calibmsg->straight_left;
                            kilo_straight_right = calibmsg->straight_right;
                        }
                        break;
                }
                if (calibmsg->mode != CALIB_SAVE && kilo_state != MOVING) {
    1468:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <kilo_state>
    146c:	86 30       	cpi	r24, 0x06	; 6
    146e:	09 f4       	brne	.+2      	; 0x1472 <__vector_23+0x278>
    1470:	04 cf       	rjmp	.-504    	; 0x127a <__vector_23+0x80>
                    motors_on();
    1472:	53 9a       	sbi	0x0a, 3	; 10
    1474:	23 9a       	sbi	0x04, 3	; 4
    1476:	10 92 b4 00 	sts	0x00B4, r1	; 0x8000b4 <__DATA_REGION_ORIGIN__+0x54>
    147a:	10 92 b3 00 	sts	0x00B3, r1	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
                    kilo_state = MOVING;
    147e:	86 e0       	ldi	r24, 0x06	; 6
    1480:	80 93 13 01 	sts	0x0113, r24	; 0x800113 <kilo_state>
    1484:	fa ce       	rjmp	.-524    	; 0x127a <__vector_23+0x80>
                }
                break;
            case READUID:
                if (kilo_state != MOVING) {
    1486:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <kilo_state>
    148a:	86 30       	cpi	r24, 0x06	; 6
    148c:	99 f0       	breq	.+38     	; 0x14b4 <__vector_23+0x2ba>
                    motors_on();
    148e:	53 9a       	sbi	0x0a, 3	; 10
    1490:	23 9a       	sbi	0x04, 3	; 4
    1492:	10 92 b4 00 	sts	0x00B4, r1	; 0x8000b4 <__DATA_REGION_ORIGIN__+0x54>
    1496:	10 92 b3 00 	sts	0x00B3, r1	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>

void set_color(uint8_t rgb) {
    if (rgb&(1<<0))
        DDRD |= (1<<5);
    else
        DDRD &= ~(1<<5);
    149a:	55 98       	cbi	0x0a, 5	; 10

    if (rgb&(1<<1))
        DDRD |= (1<<4);
    else
        DDRD &= ~(1<<4);
    149c:	54 98       	cbi	0x0a, 4	; 10

    if (rgb&(1<<2))
        DDRC |= (1<<3);
    else
        DDRC &= ~(1<<3);
    149e:	3b 98       	cbi	0x07, 3	; 7

    if (rgb&(1<<3))
        DDRC |= (1<<2);
    else
        DDRC &= ~(1<<2);
    14a0:	3a 98       	cbi	0x07, 2	; 7

    if (rgb&(1<<4))
        DDRC |= (1<<5);
    else
        DDRC &= ~(1<<5);
    14a2:	3d 98       	cbi	0x07, 5	; 7

    if (rgb&(1<<5))
        DDRC |= (1<<4);
    else
        DDRC &= ~(1<<4);
    14a4:	3c 98       	cbi	0x07, 4	; 7
                break;
            case READUID:
                if (kilo_state != MOVING) {
                    motors_on();
                    set_color(RGB(0,0,0));
                    prev_motion = cur_motion = MOVE_STOP;
    14a6:	10 92 11 01 	sts	0x0111, r1	; 0x800111 <cur_motion>
    14aa:	10 92 12 01 	sts	0x0112, r1	; 0x800112 <prev_motion>
                    kilo_state = MOVING;
    14ae:	86 e0       	ldi	r24, 0x06	; 6
    14b0:	80 93 13 01 	sts	0x0113, r24	; 0x800113 <kilo_state>
                }

                if (kilo_uid&(1<<rx_msg.data[0]))
    14b4:	81 e0       	ldi	r24, 0x01	; 1
    14b6:	90 e0       	ldi	r25, 0x00	; 0
    14b8:	9c 01       	movw	r18, r24
    14ba:	00 90 5e 01 	lds	r0, 0x015E	; 0x80015e <rx_msg>
    14be:	02 c0       	rjmp	.+4      	; 0x14c4 <__vector_23+0x2ca>
    14c0:	22 0f       	add	r18, r18
    14c2:	33 1f       	adc	r19, r19
    14c4:	0a 94       	dec	r0
    14c6:	e2 f7       	brpl	.-8      	; 0x14c0 <__vector_23+0x2c6>
    14c8:	80 91 6d 01 	lds	r24, 0x016D	; 0x80016d <kilo_uid>
    14cc:	90 91 6e 01 	lds	r25, 0x016E	; 0x80016e <kilo_uid+0x1>
    14d0:	82 23       	and	r24, r18
    14d2:	93 23       	and	r25, r19
    14d4:	89 2b       	or	r24, r25
    14d6:	b9 f4       	brne	.+46     	; 0x1506 <__vector_23+0x30c>
                    cur_motion = MOVE_LEFT;
                else
                    cur_motion = MOVE_STOP;
    14d8:	10 92 11 01 	sts	0x0111, r1	; 0x800111 <cur_motion>
                    }
                }
            }
        }
    }
}
    14dc:	ce ce       	rjmp	.-612    	; 0x127a <__vector_23+0x80>
                break;
            case VOLTAGE:
                kilo_state = BATTERY;
                break;
            case RUN:
                if (kilo_state != SETUP && kilo_state != RUNNING) {
    14de:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <kilo_state>
    14e2:	83 30       	cpi	r24, 0x03	; 3
    14e4:	09 f4       	brne	.+2      	; 0x14e8 <__vector_23+0x2ee>
    14e6:	c9 ce       	rjmp	.-622    	; 0x127a <__vector_23+0x80>
    14e8:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <kilo_state>
    14ec:	84 30       	cpi	r24, 0x04	; 4
    14ee:	09 f4       	brne	.+2      	; 0x14f2 <__vector_23+0x2f8>
    14f0:	c4 ce       	rjmp	.-632    	; 0x127a <__vector_23+0x80>
                    motors_on();
    14f2:	53 9a       	sbi	0x0a, 3	; 10
    14f4:	23 9a       	sbi	0x04, 3	; 4
    14f6:	10 92 b4 00 	sts	0x00B4, r1	; 0x8000b4 <__DATA_REGION_ORIGIN__+0x54>
    14fa:	10 92 b3 00 	sts	0x00B3, r1	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
                    kilo_state = SETUP;
    14fe:	83 e0       	ldi	r24, 0x03	; 3
    1500:	80 93 13 01 	sts	0x0113, r24	; 0x800113 <kilo_state>
    1504:	ba ce       	rjmp	.-652    	; 0x127a <__vector_23+0x80>
                    prev_motion = cur_motion = MOVE_STOP;
                    kilo_state = MOVING;
                }

                if (kilo_uid&(1<<rx_msg.data[0]))
                    cur_motion = MOVE_LEFT;
    1506:	81 e0       	ldi	r24, 0x01	; 1
    1508:	80 93 11 01 	sts	0x0111, r24	; 0x800111 <cur_motion>
    150c:	b6 ce       	rjmp	.-660    	; 0x127a <__vector_23+0x80>
                break;
            case CHARGE:
                kilo_state = CHARGING;
                break;
            case VOLTAGE:
                kilo_state = BATTERY;
    150e:	82 e0       	ldi	r24, 0x02	; 2
    1510:	80 93 13 01 	sts	0x0113, r24	; 0x800113 <kilo_state>
    1514:	b2 ce       	rjmp	.-668    	; 0x127a <__vector_23+0x80>
                break;
            case WAKEUP:
                kilo_state = IDLE;
                break;
            case CHARGE:
                kilo_state = CHARGING;
    1516:	85 e0       	ldi	r24, 0x05	; 5
    1518:	80 93 13 01 	sts	0x0113, r24	; 0x800113 <kilo_state>
    151c:	ae ce       	rjmp	.-676    	; 0x127a <__vector_23+0x80>
                break;
            case SLEEP:
                kilo_state = SLEEPING;
                break;
            case WAKEUP:
                kilo_state = IDLE;
    151e:	81 e0       	ldi	r24, 0x01	; 1
    1520:	80 93 13 01 	sts	0x0113, r24	; 0x800113 <kilo_state>
    1524:	aa ce       	rjmp	.-684    	; 0x127a <__vector_23+0x80>
                break;
            case RESET:
                reset();
                break;
            case SLEEP:
                kilo_state = SLEEPING;
    1526:	10 92 13 01 	sts	0x0113, r1	; 0x800113 <kilo_state>
    152a:	a7 ce       	rjmp	.-690    	; 0x127a <__vector_23+0x80>
            case BOOT:
                tx_timer_off();
                bootload();
                break;
            case RESET:
                reset();
    152c:	e0 e0       	ldi	r30, 0x00	; 0
    152e:	f0 e0       	ldi	r31, 0x00	; 0
    1530:	09 95       	icall

        if (rx_msg.type != READUID && rx_msg.type != RUN && rx_msg.type != CALIB)
            motors_off();
        switch (rx_msg.type) {
            case BOOT:
                tx_timer_off();
    1532:	80 91 6e 00 	lds	r24, 0x006E	; 0x80006e <__DATA_REGION_ORIGIN__+0xe>
    1536:	8d 7f       	andi	r24, 0xFD	; 253
    1538:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__DATA_REGION_ORIGIN__+0xe>
    153c:	16 bc       	out	0x26, r1	; 38
                bootload();
    153e:	e0 e0       	ldi	r30, 0x00	; 0
    1540:	f0 e7       	ldi	r31, 0x70	; 112
    1542:	09 95       	icall
                }
                break;
            case CALIB:
                switch(calibmsg->mode) {
                    case CALIB_SAVE:
                        if (kilo_state == MOVING) {
    1544:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <kilo_state>
    1548:	86 30       	cpi	r24, 0x06	; 6
    154a:	09 f0       	breq	.+2      	; 0x154e <__vector_23+0x354>
    154c:	96 ce       	rjmp	.-724    	; 0x127a <__vector_23+0x80>
                            eeprom_write_byte(EEPROM_UID, kilo_uid&0xFF);
    154e:	60 91 6d 01 	lds	r22, 0x016D	; 0x80016d <kilo_uid>
    1552:	80 eb       	ldi	r24, 0xB0	; 176
    1554:	90 e0       	ldi	r25, 0x00	; 0
    1556:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <eeprom_write_byte>
                            eeprom_write_byte(EEPROM_UID+1, (kilo_uid>>8)&0xFF);
    155a:	60 91 6e 01 	lds	r22, 0x016E	; 0x80016e <kilo_uid+0x1>
    155e:	81 eb       	ldi	r24, 0xB1	; 177
    1560:	90 e0       	ldi	r25, 0x00	; 0
    1562:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <eeprom_write_byte>
                            eeprom_write_byte(EEPROM_LEFT_ROTATE, kilo_turn_left);
    1566:	60 91 72 01 	lds	r22, 0x0172	; 0x800172 <kilo_turn_left>
    156a:	85 e0       	ldi	r24, 0x05	; 5
    156c:	90 e0       	ldi	r25, 0x00	; 0
    156e:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <eeprom_write_byte>
                            eeprom_write_byte(EEPROM_RIGHT_ROTATE, kilo_turn_right);
    1572:	60 91 5d 01 	lds	r22, 0x015D	; 0x80015d <kilo_turn_right>
    1576:	89 e0       	ldi	r24, 0x09	; 9
    1578:	90 e0       	ldi	r25, 0x00	; 0
    157a:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <eeprom_write_byte>
                            eeprom_write_byte(EEPROM_LEFT_STRAIGHT, kilo_straight_left);
    157e:	60 91 70 01 	lds	r22, 0x0170	; 0x800170 <kilo_straight_left>
    1582:	8c e0       	ldi	r24, 0x0C	; 12
    1584:	90 e0       	ldi	r25, 0x00	; 0
    1586:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <eeprom_write_byte>
                            eeprom_write_byte(EEPROM_RIGHT_STRAIGHT, kilo_straight_right);
    158a:	60 91 71 01 	lds	r22, 0x0171	; 0x800171 <kilo_straight_right>
    158e:	84 e1       	ldi	r24, 0x14	; 20
    1590:	90 e0       	ldi	r25, 0x00	; 0
    1592:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <eeprom_write_byte>
                            motors_off();
    1596:	53 98       	cbi	0x0a, 3	; 10
    1598:	23 98       	cbi	0x04, 3	; 4
    159a:	10 92 b4 00 	sts	0x00B4, r1	; 0x8000b4 <__DATA_REGION_ORIGIN__+0x54>
    159e:	10 92 b3 00 	sts	0x00B3, r1	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
                            kilo_state = IDLE;
    15a2:	81 e0       	ldi	r24, 0x01	; 1
    15a4:	80 93 13 01 	sts	0x0113, r24	; 0x800113 <kilo_state>
    15a8:	80 91 5e 01 	lds	r24, 0x015E	; 0x80015e <rx_msg>
                            kilo_straight_left = calibmsg->straight_left;
                            kilo_straight_right = calibmsg->straight_right;
                        }
                        break;
                }
                if (calibmsg->mode != CALIB_SAVE && kilo_state != MOVING) {
    15ac:	81 11       	cpse	r24, r1
    15ae:	5c cf       	rjmp	.-328    	; 0x1468 <__vector_23+0x26e>
    15b0:	64 ce       	rjmp	.-824    	; 0x127a <__vector_23+0x80>
                    motors_on();
                    kilo_state = SETUP;
                }
                break;
            case CALIB:
                switch(calibmsg->mode) {
    15b2:	83 30       	cpi	r24, 0x03	; 3
    15b4:	69 f1       	breq	.+90     	; 0x1610 <__vector_23+0x416>
    15b6:	84 30       	cpi	r24, 0x04	; 4
    15b8:	c9 f7       	brne	.-14     	; 0x15ac <__vector_23+0x3b2>
                            cur_motion = MOVE_RIGHT;
                            kilo_turn_right = calibmsg->turn_right;
                        }
                        break;
                    case CALIB_STRAIGHT:
                        if (cur_motion != MOVE_STRAIGHT || kilo_straight_right != calibmsg->straight_right || kilo_straight_left != calibmsg->straight_left) {
    15ba:	80 91 11 01 	lds	r24, 0x0111	; 0x800111 <cur_motion>
    15be:	90 91 64 01 	lds	r25, 0x0164	; 0x800164 <rx_msg+0x6>
    15c2:	83 30       	cpi	r24, 0x03	; 3
    15c4:	d1 f0       	breq	.+52     	; 0x15fa <__vector_23+0x400>
    15c6:	80 91 63 01 	lds	r24, 0x0163	; 0x800163 <rx_msg+0x5>
                            prev_motion = MOVE_STOP;
    15ca:	10 92 12 01 	sts	0x0112, r1	; 0x800112 <prev_motion>
                            cur_motion = MOVE_STRAIGHT;
    15ce:	23 e0       	ldi	r18, 0x03	; 3
    15d0:	20 93 11 01 	sts	0x0111, r18	; 0x800111 <cur_motion>
                            kilo_straight_left = calibmsg->straight_left;
    15d4:	80 93 70 01 	sts	0x0170, r24	; 0x800170 <kilo_straight_left>
                            kilo_straight_right = calibmsg->straight_right;
    15d8:	90 93 71 01 	sts	0x0171, r25	; 0x800171 <kilo_straight_right>
    15dc:	45 cf       	rjmp	.-374    	; 0x1468 <__vector_23+0x26e>
                    case CALIB_UID:
                        kilo_uid = calibmsg->uid;
                        cur_motion = MOVE_STOP;
                        break;
                    case CALIB_TURN_LEFT:
                        if (cur_motion != MOVE_LEFT || kilo_turn_left != calibmsg->turn_left) {
    15de:	80 91 11 01 	lds	r24, 0x0111	; 0x800111 <cur_motion>
    15e2:	81 30       	cpi	r24, 0x01	; 1
    15e4:	19 f1       	breq	.+70     	; 0x162c <__vector_23+0x432>
    15e6:	80 91 61 01 	lds	r24, 0x0161	; 0x800161 <rx_msg+0x3>
                            prev_motion = MOVE_STOP;
    15ea:	10 92 12 01 	sts	0x0112, r1	; 0x800112 <prev_motion>
                            cur_motion = MOVE_LEFT;
    15ee:	91 e0       	ldi	r25, 0x01	; 1
    15f0:	90 93 11 01 	sts	0x0111, r25	; 0x800111 <cur_motion>
                            kilo_turn_left = calibmsg->turn_left;
    15f4:	80 93 72 01 	sts	0x0172, r24	; 0x800172 <kilo_turn_left>
    15f8:	37 cf       	rjmp	.-402    	; 0x1468 <__vector_23+0x26e>
                            cur_motion = MOVE_RIGHT;
                            kilo_turn_right = calibmsg->turn_right;
                        }
                        break;
                    case CALIB_STRAIGHT:
                        if (cur_motion != MOVE_STRAIGHT || kilo_straight_right != calibmsg->straight_right || kilo_straight_left != calibmsg->straight_left) {
    15fa:	80 91 71 01 	lds	r24, 0x0171	; 0x800171 <kilo_straight_right>
    15fe:	98 13       	cpse	r25, r24
    1600:	e2 cf       	rjmp	.-60     	; 0x15c6 <__vector_23+0x3cc>
    1602:	80 91 63 01 	lds	r24, 0x0163	; 0x800163 <rx_msg+0x5>
    1606:	20 91 70 01 	lds	r18, 0x0170	; 0x800170 <kilo_straight_left>
    160a:	82 13       	cpse	r24, r18
    160c:	de cf       	rjmp	.-68     	; 0x15ca <__vector_23+0x3d0>
    160e:	2c cf       	rjmp	.-424    	; 0x1468 <__vector_23+0x26e>
                            cur_motion = MOVE_LEFT;
                            kilo_turn_left = calibmsg->turn_left;
                        }
                        break;
                    case CALIB_TURN_RIGHT:
                        if (cur_motion != MOVE_RIGHT || kilo_turn_right != calibmsg->turn_right) {
    1610:	80 91 11 01 	lds	r24, 0x0111	; 0x800111 <cur_motion>
    1614:	82 30       	cpi	r24, 0x02	; 2
    1616:	89 f0       	breq	.+34     	; 0x163a <__vector_23+0x440>
    1618:	80 91 62 01 	lds	r24, 0x0162	; 0x800162 <rx_msg+0x4>
                            prev_motion = MOVE_STOP;
    161c:	10 92 12 01 	sts	0x0112, r1	; 0x800112 <prev_motion>
                            cur_motion = MOVE_RIGHT;
    1620:	92 e0       	ldi	r25, 0x02	; 2
    1622:	90 93 11 01 	sts	0x0111, r25	; 0x800111 <cur_motion>
                            kilo_turn_right = calibmsg->turn_right;
    1626:	80 93 5d 01 	sts	0x015D, r24	; 0x80015d <kilo_turn_right>
    162a:	1e cf       	rjmp	.-452    	; 0x1468 <__vector_23+0x26e>
                    case CALIB_UID:
                        kilo_uid = calibmsg->uid;
                        cur_motion = MOVE_STOP;
                        break;
                    case CALIB_TURN_LEFT:
                        if (cur_motion != MOVE_LEFT || kilo_turn_left != calibmsg->turn_left) {
    162c:	80 91 61 01 	lds	r24, 0x0161	; 0x800161 <rx_msg+0x3>
    1630:	90 91 72 01 	lds	r25, 0x0172	; 0x800172 <kilo_turn_left>
    1634:	89 13       	cpse	r24, r25
    1636:	d9 cf       	rjmp	.-78     	; 0x15ea <__vector_23+0x3f0>
    1638:	17 cf       	rjmp	.-466    	; 0x1468 <__vector_23+0x26e>
                            cur_motion = MOVE_LEFT;
                            kilo_turn_left = calibmsg->turn_left;
                        }
                        break;
                    case CALIB_TURN_RIGHT:
                        if (cur_motion != MOVE_RIGHT || kilo_turn_right != calibmsg->turn_right) {
    163a:	80 91 62 01 	lds	r24, 0x0162	; 0x800162 <rx_msg+0x4>
    163e:	90 91 5d 01 	lds	r25, 0x015D	; 0x80015d <kilo_turn_right>
    1642:	89 13       	cpse	r24, r25
    1644:	eb cf       	rjmp	.-42     	; 0x161c <__vector_23+0x422>
    1646:	10 cf       	rjmp	.-480    	; 0x1468 <__vector_23+0x26e>

00001648 <message_crc>:
#include "message.h"
#include <util/crc16.h>  // for optimized crc routines

uint16_t message_crc(const message_t *msg) {
    1648:	fc 01       	movw	r30, r24
static __inline__ uint16_t
_crc_ccitt_update (uint16_t __crc, uint8_t __data)
{
    uint16_t __ret;

    __asm__ __volatile__ (
    164a:	80 81       	ld	r24, Z
    164c:	2f ef       	ldi	r18, 0xFF	; 255
    164e:	3f ef       	ldi	r19, 0xFF	; 255
    1650:	28 27       	eor	r18, r24
    1652:	02 2e       	mov	r0, r18
    1654:	22 95       	swap	r18
    1656:	20 7f       	andi	r18, 0xF0	; 240
    1658:	20 25       	eor	r18, r0
    165a:	03 2e       	mov	r0, r19
    165c:	32 2f       	mov	r19, r18
    165e:	22 95       	swap	r18
    1660:	2f 70       	andi	r18, 0x0F	; 15
    1662:	02 26       	eor	r0, r18
    1664:	26 95       	lsr	r18
    1666:	32 27       	eor	r19, r18
    1668:	23 27       	eor	r18, r19
    166a:	22 0f       	add	r18, r18
    166c:	22 0f       	add	r18, r18
    166e:	22 0f       	add	r18, r18
    1670:	20 25       	eor	r18, r0
    1672:	81 81       	ldd	r24, Z+1	; 0x01
    1674:	28 27       	eor	r18, r24
    1676:	02 2e       	mov	r0, r18
    1678:	22 95       	swap	r18
    167a:	20 7f       	andi	r18, 0xF0	; 240
    167c:	20 25       	eor	r18, r0
    167e:	03 2e       	mov	r0, r19
    1680:	32 2f       	mov	r19, r18
    1682:	22 95       	swap	r18
    1684:	2f 70       	andi	r18, 0x0F	; 15
    1686:	02 26       	eor	r0, r18
    1688:	26 95       	lsr	r18
    168a:	32 27       	eor	r19, r18
    168c:	23 27       	eor	r18, r19
    168e:	22 0f       	add	r18, r18
    1690:	22 0f       	add	r18, r18
    1692:	22 0f       	add	r18, r18
    1694:	20 25       	eor	r18, r0
    1696:	82 81       	ldd	r24, Z+2	; 0x02
    1698:	28 27       	eor	r18, r24
    169a:	02 2e       	mov	r0, r18
    169c:	22 95       	swap	r18
    169e:	20 7f       	andi	r18, 0xF0	; 240
    16a0:	20 25       	eor	r18, r0
    16a2:	03 2e       	mov	r0, r19
    16a4:	32 2f       	mov	r19, r18
    16a6:	22 95       	swap	r18
    16a8:	2f 70       	andi	r18, 0x0F	; 15
    16aa:	02 26       	eor	r0, r18
    16ac:	26 95       	lsr	r18
    16ae:	32 27       	eor	r19, r18
    16b0:	23 27       	eor	r18, r19
    16b2:	22 0f       	add	r18, r18
    16b4:	22 0f       	add	r18, r18
    16b6:	22 0f       	add	r18, r18
    16b8:	20 25       	eor	r18, r0
    16ba:	83 81       	ldd	r24, Z+3	; 0x03
    16bc:	28 27       	eor	r18, r24
    16be:	02 2e       	mov	r0, r18
    16c0:	22 95       	swap	r18
    16c2:	20 7f       	andi	r18, 0xF0	; 240
    16c4:	20 25       	eor	r18, r0
    16c6:	03 2e       	mov	r0, r19
    16c8:	32 2f       	mov	r19, r18
    16ca:	22 95       	swap	r18
    16cc:	2f 70       	andi	r18, 0x0F	; 15
    16ce:	02 26       	eor	r0, r18
    16d0:	26 95       	lsr	r18
    16d2:	32 27       	eor	r19, r18
    16d4:	23 27       	eor	r18, r19
    16d6:	22 0f       	add	r18, r18
    16d8:	22 0f       	add	r18, r18
    16da:	22 0f       	add	r18, r18
    16dc:	20 25       	eor	r18, r0
    16de:	84 81       	ldd	r24, Z+4	; 0x04
    16e0:	28 27       	eor	r18, r24
    16e2:	02 2e       	mov	r0, r18
    16e4:	22 95       	swap	r18
    16e6:	20 7f       	andi	r18, 0xF0	; 240
    16e8:	20 25       	eor	r18, r0
    16ea:	03 2e       	mov	r0, r19
    16ec:	32 2f       	mov	r19, r18
    16ee:	22 95       	swap	r18
    16f0:	2f 70       	andi	r18, 0x0F	; 15
    16f2:	02 26       	eor	r0, r18
    16f4:	26 95       	lsr	r18
    16f6:	32 27       	eor	r19, r18
    16f8:	23 27       	eor	r18, r19
    16fa:	22 0f       	add	r18, r18
    16fc:	22 0f       	add	r18, r18
    16fe:	22 0f       	add	r18, r18
    1700:	20 25       	eor	r18, r0
    1702:	85 81       	ldd	r24, Z+5	; 0x05
    1704:	28 27       	eor	r18, r24
    1706:	02 2e       	mov	r0, r18
    1708:	22 95       	swap	r18
    170a:	20 7f       	andi	r18, 0xF0	; 240
    170c:	20 25       	eor	r18, r0
    170e:	03 2e       	mov	r0, r19
    1710:	32 2f       	mov	r19, r18
    1712:	22 95       	swap	r18
    1714:	2f 70       	andi	r18, 0x0F	; 15
    1716:	02 26       	eor	r0, r18
    1718:	26 95       	lsr	r18
    171a:	32 27       	eor	r19, r18
    171c:	23 27       	eor	r18, r19
    171e:	22 0f       	add	r18, r18
    1720:	22 0f       	add	r18, r18
    1722:	22 0f       	add	r18, r18
    1724:	20 25       	eor	r18, r0
    1726:	86 81       	ldd	r24, Z+6	; 0x06
    1728:	28 27       	eor	r18, r24
    172a:	02 2e       	mov	r0, r18
    172c:	22 95       	swap	r18
    172e:	20 7f       	andi	r18, 0xF0	; 240
    1730:	20 25       	eor	r18, r0
    1732:	03 2e       	mov	r0, r19
    1734:	32 2f       	mov	r19, r18
    1736:	22 95       	swap	r18
    1738:	2f 70       	andi	r18, 0x0F	; 15
    173a:	02 26       	eor	r0, r18
    173c:	26 95       	lsr	r18
    173e:	32 27       	eor	r19, r18
    1740:	23 27       	eor	r18, r19
    1742:	22 0f       	add	r18, r18
    1744:	22 0f       	add	r18, r18
    1746:	22 0f       	add	r18, r18
    1748:	20 25       	eor	r18, r0
    174a:	87 81       	ldd	r24, Z+7	; 0x07
    174c:	28 27       	eor	r18, r24
    174e:	02 2e       	mov	r0, r18
    1750:	22 95       	swap	r18
    1752:	20 7f       	andi	r18, 0xF0	; 240
    1754:	20 25       	eor	r18, r0
    1756:	03 2e       	mov	r0, r19
    1758:	32 2f       	mov	r19, r18
    175a:	22 95       	swap	r18
    175c:	2f 70       	andi	r18, 0x0F	; 15
    175e:	02 26       	eor	r0, r18
    1760:	26 95       	lsr	r18
    1762:	32 27       	eor	r19, r18
    1764:	23 27       	eor	r18, r19
    1766:	22 0f       	add	r18, r18
    1768:	22 0f       	add	r18, r18
    176a:	22 0f       	add	r18, r18
    176c:	20 25       	eor	r18, r0
    176e:	80 85       	ldd	r24, Z+8	; 0x08
    1770:	28 27       	eor	r18, r24
    1772:	02 2e       	mov	r0, r18
    1774:	22 95       	swap	r18
    1776:	20 7f       	andi	r18, 0xF0	; 240
    1778:	20 25       	eor	r18, r0
    177a:	03 2e       	mov	r0, r19
    177c:	32 2f       	mov	r19, r18
    177e:	22 95       	swap	r18
    1780:	2f 70       	andi	r18, 0x0F	; 15
    1782:	02 26       	eor	r0, r18
    1784:	26 95       	lsr	r18
    1786:	32 27       	eor	r19, r18
    1788:	23 27       	eor	r18, r19
    178a:	22 0f       	add	r18, r18
    178c:	22 0f       	add	r18, r18
    178e:	22 0f       	add	r18, r18
    1790:	20 25       	eor	r18, r0
    1792:	41 85       	ldd	r20, Z+9	; 0x09
    1794:	c9 01       	movw	r24, r18
    1796:	84 27       	eor	r24, r20
    1798:	08 2e       	mov	r0, r24
    179a:	82 95       	swap	r24
    179c:	80 7f       	andi	r24, 0xF0	; 240
    179e:	80 25       	eor	r24, r0
    17a0:	09 2e       	mov	r0, r25
    17a2:	98 2f       	mov	r25, r24
    17a4:	82 95       	swap	r24
    17a6:	8f 70       	andi	r24, 0x0F	; 15
    17a8:	08 26       	eor	r0, r24
    17aa:	86 95       	lsr	r24
    17ac:	98 27       	eor	r25, r24
    17ae:	89 27       	eor	r24, r25
    17b0:	88 0f       	add	r24, r24
    17b2:	88 0f       	add	r24, r24
    17b4:	88 0f       	add	r24, r24
    17b6:	80 25       	eor	r24, r0
    const uint8_t *rawmsg = (const uint8_t*)msg;
    uint16_t crc = 0xFFFF;
    for (i = 0; i<sizeof(message_t)-sizeof(msg->crc); i++)
        crc = _crc_ccitt_update(crc, rawmsg[i]);
    return crc;
}
    17b8:	08 95       	ret

000017ba <message_send>:
.global message_send

message_send:
    ; save interrupt state
    ; sreg = SREG
    in sreg, SREG
    17ba:	0f b6       	in	r0, 0x3f	; 63
#ifndef OHC
    cli
    17bc:	f8 94       	cli
#endif
    ; ddreg = IR_DDR
    in  ddrreg,  IR_DDR
    17be:	a4 b1       	in	r26, 0x04	; 4

    ; IR_DDR |= tx_mask
    lds tmpreg1, tx_mask
    17c0:	20 91 31 01 	lds	r18, 0x0131	; 0x800131 <tx_mask>
    or tmpreg1, ddrreg
    17c4:	2a 2b       	or	r18, r26
    out IR_DDR, tmpreg1
    17c6:	24 b9       	out	0x04, r18	; 4

    ldi tmpreg1, 0x01
    17c8:	21 e0       	ldi	r18, 0x01	; 1
    irsend
    17ca:	30 91 31 01 	lds	r19, 0x0131	; 0x800131 <tx_mask>
    17ce:	20 30       	cpi	r18, 0x00	; 0
    17d0:	29 f0       	breq	.+10     	; 0x17dc <message_send+0x22>
    17d2:	00 00       	nop
    17d4:	25 b1       	in	r18, 0x05	; 5
    17d6:	23 2b       	or	r18, r19
    17d8:	25 b9       	out	0x05, r18	; 5
    17da:	04 c0       	rjmp	.+8      	; 0x17e4 <message_send+0x2a>
    17dc:	00 00       	nop
    17de:	00 00       	nop
    17e0:	00 00       	nop
    17e2:	00 c0       	rjmp	.+0      	; 0x17e4 <message_send+0x2a>
    17e4:	00 00       	nop
    17e6:	00 00       	nop
    17e8:	00 00       	nop
    17ea:	30 95       	com	r19
    17ec:	25 b1       	in	r18, 0x05	; 5
    17ee:	23 23       	and	r18, r19
    17f0:	25 b9       	out	0x05, r18	; 5
    delay_cycles (2*rx_bitcycles-irsend_cycles)
    17f2:	2e ea       	ldi	r18, 0xAE	; 174
    17f4:	2a 95       	dec	r18
    17f6:	f1 f7       	brne	.-4      	; 0x17f4 <message_send+0x3a>

    ldi tmpreg1, rx_bitcycles*7/8
    17f8:	2b ee       	ldi	r18, 0xEB	; 235

000017fa <checkcollision>:
checkcollision:
    ; if (ACSR&(1<<ACO)) == 0 goto nocollision
    in tmpreg2, ACSR
    17fa:	30 b7       	in	r19, 0x30	; 48
    sbrs tmpreg2, ACO
    17fc:	35 ff       	sbrs	r19, 5
    rjmp nocollision
    17fe:	0a c0       	rjmp	.+20     	; 0x1814 <nocollision>
    ; IR_DDR = ddrreg
    out IR_DDR, ddrreg
    1800:	a4 b9       	out	0x04, r26	; 4
    ; IR_PORT &= ~(tx_mask)
    lds tmpreg2, tx_mask
    1802:	30 91 31 01 	lds	r19, 0x0131	; 0x800131 <tx_mask>
    com tmpreg2
    1806:	30 95       	com	r19
    in tmpreg1, IR_PORT
    1808:	25 b1       	in	r18, 0x05	; 5
    and tmpreg1, tmpreg2
    180a:	23 23       	and	r18, r19
    out IR_PORT, tmpreg1
    180c:	25 b9       	out	0x05, r18	; 5
    ; restore interrupt state
    ; SREG = sreg
    out SREG, sreg
    180e:	0f be       	out	0x3f, r0	; 63
    return 0
    1810:	80 e0       	ldi	r24, 0x00	; 0
    1812:	08 95       	ret

00001814 <nocollision>:
nocollision:
    nop
    1814:	00 00       	nop
    dec tmpreg1
    1816:	2a 95       	dec	r18
    brne checkcollision
    1818:	81 f7       	brne	.-32     	; 0x17fa <checkcollision>

    ldi tmpreg1, 0x01
    181a:	21 e0       	ldi	r18, 0x01	; 1
    irsend
    181c:	30 91 31 01 	lds	r19, 0x0131	; 0x800131 <tx_mask>
    1820:	20 30       	cpi	r18, 0x00	; 0
    1822:	29 f0       	breq	.+10     	; 0x182e <nocollision+0x1a>
    1824:	00 00       	nop
    1826:	25 b1       	in	r18, 0x05	; 5
    1828:	23 2b       	or	r18, r19
    182a:	25 b9       	out	0x05, r18	; 5
    182c:	04 c0       	rjmp	.+8      	; 0x1836 <nocollision+0x22>
    182e:	00 00       	nop
    1830:	00 00       	nop
    1832:	00 00       	nop
    1834:	00 c0       	rjmp	.+0      	; 0x1836 <nocollision+0x22>
    1836:	00 00       	nop
    1838:	00 00       	nop
    183a:	00 00       	nop
    183c:	30 95       	com	r19
    183e:	25 b1       	in	r18, 0x05	; 5
    1840:	23 23       	and	r18, r19
    1842:	25 b9       	out	0x05, r18	; 5
    delay_cycles (rx_bitcycles-irsend_cycles)
    1844:	00 00       	nop
    1846:	24 e5       	ldi	r18, 0x54	; 84
    1848:	2a 95       	dec	r18
    184a:	f1 f7       	brne	.-4      	; 0x1848 <nocollision+0x34>

    movw r30, r24     ; // copy msg pointer in r24:r25 to r30:r31
    184c:	fc 01       	movw	r30, r24
    ldi byteidx, 12
    184e:	8c e0       	ldi	r24, 0x0C	; 12

00001850 <sendbyte>:

sendbyte:
    ; byteval = msg[i++]<<1 | (1<<0) | (1<<9)
    ld bytevalL, Z+
    1850:	61 91       	ld	r22, Z+
    ldi bytevalH, 0x00
    1852:	70 e0       	ldi	r23, 0x00	; 0
    add bytevalL, bytevalL
    1854:	66 0f       	add	r22, r22
    adc bytevalH, bytevalH
    1856:	77 1f       	adc	r23, r23
    ori bytevalL, 0x01
    1858:	61 60       	ori	r22, 0x01	; 1
    ori bytevalH, 0x02
    185a:	72 60       	ori	r23, 0x02	; 2
    ; bitidex = 10
    ldi bitidx, 10
    185c:	9a e0       	ldi	r25, 0x0A	; 10
    ; bitmask = 0x00001
    ldi bitmaskL, 0x01
    185e:	41 e0       	ldi	r20, 0x01	; 1
    ldi bitmaskH, 0x00
    1860:	50 e0       	ldi	r21, 0x00	; 0

00001862 <sendbit>:

    ; 9 cycles per iteration + irsend
sendbit:
    ; tmpreg = (byteval&bytemask)
    movw tmpreg1, bitmaskL
    1862:	9a 01       	movw	r18, r20
    and tmpreg1, bytevalL
    1864:	26 23       	and	r18, r22
    and tmpreg2, bytevalH
    1866:	37 23       	and	r19, r23
    or  tmpreg1, tmpreg2
    1868:	23 2b       	or	r18, r19

    ; irsend tmpreg
    irsend
    186a:	30 91 31 01 	lds	r19, 0x0131	; 0x800131 <tx_mask>
    186e:	20 30       	cpi	r18, 0x00	; 0
    1870:	29 f0       	breq	.+10     	; 0x187c <sendbit+0x1a>
    1872:	00 00       	nop
    1874:	25 b1       	in	r18, 0x05	; 5
    1876:	23 2b       	or	r18, r19
    1878:	25 b9       	out	0x05, r18	; 5
    187a:	04 c0       	rjmp	.+8      	; 0x1884 <sendbit+0x22>
    187c:	00 00       	nop
    187e:	00 00       	nop
    1880:	00 00       	nop
    1882:	00 c0       	rjmp	.+0      	; 0x1884 <sendbit+0x22>
    1884:	00 00       	nop
    1886:	00 00       	nop
    1888:	00 00       	nop
    188a:	30 95       	com	r19
    188c:	25 b1       	in	r18, 0x05	; 5
    188e:	23 23       	and	r18, r19
    1890:	25 b9       	out	0x05, r18	; 5
    delay_cycles (rx_bitcycles-irsend_cycles-9)
    1892:	00 00       	nop
    1894:	21 e5       	ldi	r18, 0x51	; 81
    1896:	2a 95       	dec	r18
    1898:	f1 f7       	brne	.-4      	; 0x1896 <sendbit+0x34>

    ; bitmask <<= 1
    add bitmaskL, bitmaskL
    189a:	44 0f       	add	r20, r20
    adc bitmaskH, bitmaskH
    189c:	55 1f       	adc	r21, r21

    ; if (bitidex--) goto sendbit
    dec bitidx
    189e:	9a 95       	dec	r25
    brne sendbit
    18a0:	01 f7       	brne	.-64     	; 0x1862 <sendbit>

    ; if (byteidx--) goto sendbyte
    dec byteidx
    18a2:	8a 95       	dec	r24
    brne sendbyte
    18a4:	a9 f6       	brne	.-86     	; 0x1850 <sendbyte>

    ; ACSR |= (1<<ACI)
    in tmpreg1, ACSR
    18a6:	20 b7       	in	r18, 0x30	; 48
    ori tmpreg1, (1<<ACI)
    18a8:	20 61       	ori	r18, 0x10	; 16
    out ACSR, tmpreg1
    18aa:	20 bf       	out	0x30, r18	; 48
    ; IR_DDR = ddrreg
    out IR_DDR, ddrreg
    18ac:	a4 b9       	out	0x04, r26	; 4

    ; IR_PORT &= ~(tx_mask)
    lds tmpreg2, tx_mask
    18ae:	30 91 31 01 	lds	r19, 0x0131	; 0x800131 <tx_mask>
    com tmpreg2
    18b2:	30 95       	com	r19
    in tmpreg1, IR_PORT
    18b4:	25 b1       	in	r18, 0x05	; 5
    and tmpreg1, tmpreg2
    18b6:	23 23       	and	r18, r19
    out IR_PORT, tmpreg1
    18b8:	25 b9       	out	0x05, r18	; 5

    ; restore interrupt state
    ; SREG = sreg
    out SREG, sreg
    18ba:	0f be       	out	0x3f, r0	; 63
    return 1
    18bc:	81 e0       	ldi	r24, 0x01	; 1
    18be:	08 95       	ret

000018c0 <main>:
}

int main() {
    kilo_init();
    18c0:	0e 94 85 00 	call	0x10a	; 0x10a <kilo_init>
    kilo_start(setup, loop);
    18c4:	62 e7       	ldi	r22, 0x72	; 114
    18c6:	70 e0       	ldi	r23, 0x00	; 0
    18c8:	81 e7       	ldi	r24, 0x71	; 113
    18ca:	90 e0       	ldi	r25, 0x00	; 0
    18cc:	0e 94 b8 01 	call	0x370	; 0x370 <kilo_start>

    return 0;
}
    18d0:	80 e0       	ldi	r24, 0x00	; 0
    18d2:	90 e0       	ldi	r25, 0x00	; 0
    18d4:	08 95       	ret

000018d6 <__divmodhi4>:
    18d6:	97 fb       	bst	r25, 7
    18d8:	07 2e       	mov	r0, r23
    18da:	16 f4       	brtc	.+4      	; 0x18e0 <__divmodhi4+0xa>
    18dc:	00 94       	com	r0
    18de:	07 d0       	rcall	.+14     	; 0x18ee <__divmodhi4_neg1>
    18e0:	77 fd       	sbrc	r23, 7
    18e2:	09 d0       	rcall	.+18     	; 0x18f6 <__divmodhi4_neg2>
    18e4:	0e 94 94 0c 	call	0x1928	; 0x1928 <__udivmodhi4>
    18e8:	07 fc       	sbrc	r0, 7
    18ea:	05 d0       	rcall	.+10     	; 0x18f6 <__divmodhi4_neg2>
    18ec:	3e f4       	brtc	.+14     	; 0x18fc <__divmodhi4_exit>

000018ee <__divmodhi4_neg1>:
    18ee:	90 95       	com	r25
    18f0:	81 95       	neg	r24
    18f2:	9f 4f       	sbci	r25, 0xFF	; 255
    18f4:	08 95       	ret

000018f6 <__divmodhi4_neg2>:
    18f6:	70 95       	com	r23
    18f8:	61 95       	neg	r22
    18fa:	7f 4f       	sbci	r23, 0xFF	; 255

000018fc <__divmodhi4_exit>:
    18fc:	08 95       	ret

000018fe <__tablejump2__>:
    18fe:	ee 0f       	add	r30, r30
    1900:	ff 1f       	adc	r31, r31
    1902:	05 90       	lpm	r0, Z+
    1904:	f4 91       	lpm	r31, Z
    1906:	e0 2d       	mov	r30, r0
    1908:	09 94       	ijmp

0000190a <__umulhisi3>:
    190a:	a2 9f       	mul	r26, r18
    190c:	b0 01       	movw	r22, r0
    190e:	b3 9f       	mul	r27, r19
    1910:	c0 01       	movw	r24, r0
    1912:	a3 9f       	mul	r26, r19
    1914:	70 0d       	add	r23, r0
    1916:	81 1d       	adc	r24, r1
    1918:	11 24       	eor	r1, r1
    191a:	91 1d       	adc	r25, r1
    191c:	b2 9f       	mul	r27, r18
    191e:	70 0d       	add	r23, r0
    1920:	81 1d       	adc	r24, r1
    1922:	11 24       	eor	r1, r1
    1924:	91 1d       	adc	r25, r1
    1926:	08 95       	ret

00001928 <__udivmodhi4>:
    1928:	aa 1b       	sub	r26, r26
    192a:	bb 1b       	sub	r27, r27
    192c:	51 e1       	ldi	r21, 0x11	; 17
    192e:	07 c0       	rjmp	.+14     	; 0x193e <__udivmodhi4_ep>

00001930 <__udivmodhi4_loop>:
    1930:	aa 1f       	adc	r26, r26
    1932:	bb 1f       	adc	r27, r27
    1934:	a6 17       	cp	r26, r22
    1936:	b7 07       	cpc	r27, r23
    1938:	10 f0       	brcs	.+4      	; 0x193e <__udivmodhi4_ep>
    193a:	a6 1b       	sub	r26, r22
    193c:	b7 0b       	sbc	r27, r23

0000193e <__udivmodhi4_ep>:
    193e:	88 1f       	adc	r24, r24
    1940:	99 1f       	adc	r25, r25
    1942:	5a 95       	dec	r21
    1944:	a9 f7       	brne	.-22     	; 0x1930 <__udivmodhi4_loop>
    1946:	80 95       	com	r24
    1948:	90 95       	com	r25
    194a:	bc 01       	movw	r22, r24
    194c:	cd 01       	movw	r24, r26
    194e:	08 95       	ret

00001950 <__subsf3>:
    1950:	50 58       	subi	r21, 0x80	; 128

00001952 <__addsf3>:
    1952:	bb 27       	eor	r27, r27
    1954:	aa 27       	eor	r26, r26
    1956:	0e 94 c0 0c 	call	0x1980	; 0x1980 <__addsf3x>
    195a:	0c 94 11 0e 	jmp	0x1c22	; 0x1c22 <__fp_round>
    195e:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <__fp_pscA>
    1962:	38 f0       	brcs	.+14     	; 0x1972 <__addsf3+0x20>
    1964:	0e 94 0a 0e 	call	0x1c14	; 0x1c14 <__fp_pscB>
    1968:	20 f0       	brcs	.+8      	; 0x1972 <__addsf3+0x20>
    196a:	39 f4       	brne	.+14     	; 0x197a <__addsf3+0x28>
    196c:	9f 3f       	cpi	r25, 0xFF	; 255
    196e:	19 f4       	brne	.+6      	; 0x1976 <__addsf3+0x24>
    1970:	26 f4       	brtc	.+8      	; 0x197a <__addsf3+0x28>
    1972:	0c 94 00 0e 	jmp	0x1c00	; 0x1c00 <__fp_nan>
    1976:	0e f4       	brtc	.+2      	; 0x197a <__addsf3+0x28>
    1978:	e0 95       	com	r30
    197a:	e7 fb       	bst	r30, 7
    197c:	0c 94 fa 0d 	jmp	0x1bf4	; 0x1bf4 <__fp_inf>

00001980 <__addsf3x>:
    1980:	e9 2f       	mov	r30, r25
    1982:	0e 94 22 0e 	call	0x1c44	; 0x1c44 <__fp_split3>
    1986:	58 f3       	brcs	.-42     	; 0x195e <__addsf3+0xc>
    1988:	ba 17       	cp	r27, r26
    198a:	62 07       	cpc	r22, r18
    198c:	73 07       	cpc	r23, r19
    198e:	84 07       	cpc	r24, r20
    1990:	95 07       	cpc	r25, r21
    1992:	20 f0       	brcs	.+8      	; 0x199c <__addsf3x+0x1c>
    1994:	79 f4       	brne	.+30     	; 0x19b4 <__addsf3x+0x34>
    1996:	a6 f5       	brtc	.+104    	; 0x1a00 <__addsf3x+0x80>
    1998:	0c 94 44 0e 	jmp	0x1c88	; 0x1c88 <__fp_zero>
    199c:	0e f4       	brtc	.+2      	; 0x19a0 <__addsf3x+0x20>
    199e:	e0 95       	com	r30
    19a0:	0b 2e       	mov	r0, r27
    19a2:	ba 2f       	mov	r27, r26
    19a4:	a0 2d       	mov	r26, r0
    19a6:	0b 01       	movw	r0, r22
    19a8:	b9 01       	movw	r22, r18
    19aa:	90 01       	movw	r18, r0
    19ac:	0c 01       	movw	r0, r24
    19ae:	ca 01       	movw	r24, r20
    19b0:	a0 01       	movw	r20, r0
    19b2:	11 24       	eor	r1, r1
    19b4:	ff 27       	eor	r31, r31
    19b6:	59 1b       	sub	r21, r25
    19b8:	99 f0       	breq	.+38     	; 0x19e0 <__addsf3x+0x60>
    19ba:	59 3f       	cpi	r21, 0xF9	; 249
    19bc:	50 f4       	brcc	.+20     	; 0x19d2 <__addsf3x+0x52>
    19be:	50 3e       	cpi	r21, 0xE0	; 224
    19c0:	68 f1       	brcs	.+90     	; 0x1a1c <__addsf3x+0x9c>
    19c2:	1a 16       	cp	r1, r26
    19c4:	f0 40       	sbci	r31, 0x00	; 0
    19c6:	a2 2f       	mov	r26, r18
    19c8:	23 2f       	mov	r18, r19
    19ca:	34 2f       	mov	r19, r20
    19cc:	44 27       	eor	r20, r20
    19ce:	58 5f       	subi	r21, 0xF8	; 248
    19d0:	f3 cf       	rjmp	.-26     	; 0x19b8 <__addsf3x+0x38>
    19d2:	46 95       	lsr	r20
    19d4:	37 95       	ror	r19
    19d6:	27 95       	ror	r18
    19d8:	a7 95       	ror	r26
    19da:	f0 40       	sbci	r31, 0x00	; 0
    19dc:	53 95       	inc	r21
    19de:	c9 f7       	brne	.-14     	; 0x19d2 <__addsf3x+0x52>
    19e0:	7e f4       	brtc	.+30     	; 0x1a00 <__addsf3x+0x80>
    19e2:	1f 16       	cp	r1, r31
    19e4:	ba 0b       	sbc	r27, r26
    19e6:	62 0b       	sbc	r22, r18
    19e8:	73 0b       	sbc	r23, r19
    19ea:	84 0b       	sbc	r24, r20
    19ec:	ba f0       	brmi	.+46     	; 0x1a1c <__addsf3x+0x9c>
    19ee:	91 50       	subi	r25, 0x01	; 1
    19f0:	a1 f0       	breq	.+40     	; 0x1a1a <__addsf3x+0x9a>
    19f2:	ff 0f       	add	r31, r31
    19f4:	bb 1f       	adc	r27, r27
    19f6:	66 1f       	adc	r22, r22
    19f8:	77 1f       	adc	r23, r23
    19fa:	88 1f       	adc	r24, r24
    19fc:	c2 f7       	brpl	.-16     	; 0x19ee <__addsf3x+0x6e>
    19fe:	0e c0       	rjmp	.+28     	; 0x1a1c <__addsf3x+0x9c>
    1a00:	ba 0f       	add	r27, r26
    1a02:	62 1f       	adc	r22, r18
    1a04:	73 1f       	adc	r23, r19
    1a06:	84 1f       	adc	r24, r20
    1a08:	48 f4       	brcc	.+18     	; 0x1a1c <__addsf3x+0x9c>
    1a0a:	87 95       	ror	r24
    1a0c:	77 95       	ror	r23
    1a0e:	67 95       	ror	r22
    1a10:	b7 95       	ror	r27
    1a12:	f7 95       	ror	r31
    1a14:	9e 3f       	cpi	r25, 0xFE	; 254
    1a16:	08 f0       	brcs	.+2      	; 0x1a1a <__addsf3x+0x9a>
    1a18:	b0 cf       	rjmp	.-160    	; 0x197a <__addsf3+0x28>
    1a1a:	93 95       	inc	r25
    1a1c:	88 0f       	add	r24, r24
    1a1e:	08 f0       	brcs	.+2      	; 0x1a22 <__addsf3x+0xa2>
    1a20:	99 27       	eor	r25, r25
    1a22:	ee 0f       	add	r30, r30
    1a24:	97 95       	ror	r25
    1a26:	87 95       	ror	r24
    1a28:	08 95       	ret

00001a2a <__divsf3>:
    1a2a:	0e 94 29 0d 	call	0x1a52	; 0x1a52 <__divsf3x>
    1a2e:	0c 94 11 0e 	jmp	0x1c22	; 0x1c22 <__fp_round>
    1a32:	0e 94 0a 0e 	call	0x1c14	; 0x1c14 <__fp_pscB>
    1a36:	58 f0       	brcs	.+22     	; 0x1a4e <__divsf3+0x24>
    1a38:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <__fp_pscA>
    1a3c:	40 f0       	brcs	.+16     	; 0x1a4e <__divsf3+0x24>
    1a3e:	29 f4       	brne	.+10     	; 0x1a4a <__divsf3+0x20>
    1a40:	5f 3f       	cpi	r21, 0xFF	; 255
    1a42:	29 f0       	breq	.+10     	; 0x1a4e <__divsf3+0x24>
    1a44:	0c 94 fa 0d 	jmp	0x1bf4	; 0x1bf4 <__fp_inf>
    1a48:	51 11       	cpse	r21, r1
    1a4a:	0c 94 45 0e 	jmp	0x1c8a	; 0x1c8a <__fp_szero>
    1a4e:	0c 94 00 0e 	jmp	0x1c00	; 0x1c00 <__fp_nan>

00001a52 <__divsf3x>:
    1a52:	0e 94 22 0e 	call	0x1c44	; 0x1c44 <__fp_split3>
    1a56:	68 f3       	brcs	.-38     	; 0x1a32 <__divsf3+0x8>

00001a58 <__divsf3_pse>:
    1a58:	99 23       	and	r25, r25
    1a5a:	b1 f3       	breq	.-20     	; 0x1a48 <__divsf3+0x1e>
    1a5c:	55 23       	and	r21, r21
    1a5e:	91 f3       	breq	.-28     	; 0x1a44 <__divsf3+0x1a>
    1a60:	95 1b       	sub	r25, r21
    1a62:	55 0b       	sbc	r21, r21
    1a64:	bb 27       	eor	r27, r27
    1a66:	aa 27       	eor	r26, r26
    1a68:	62 17       	cp	r22, r18
    1a6a:	73 07       	cpc	r23, r19
    1a6c:	84 07       	cpc	r24, r20
    1a6e:	38 f0       	brcs	.+14     	; 0x1a7e <__divsf3_pse+0x26>
    1a70:	9f 5f       	subi	r25, 0xFF	; 255
    1a72:	5f 4f       	sbci	r21, 0xFF	; 255
    1a74:	22 0f       	add	r18, r18
    1a76:	33 1f       	adc	r19, r19
    1a78:	44 1f       	adc	r20, r20
    1a7a:	aa 1f       	adc	r26, r26
    1a7c:	a9 f3       	breq	.-22     	; 0x1a68 <__divsf3_pse+0x10>
    1a7e:	35 d0       	rcall	.+106    	; 0x1aea <__divsf3_pse+0x92>
    1a80:	0e 2e       	mov	r0, r30
    1a82:	3a f0       	brmi	.+14     	; 0x1a92 <__divsf3_pse+0x3a>
    1a84:	e0 e8       	ldi	r30, 0x80	; 128
    1a86:	32 d0       	rcall	.+100    	; 0x1aec <__divsf3_pse+0x94>
    1a88:	91 50       	subi	r25, 0x01	; 1
    1a8a:	50 40       	sbci	r21, 0x00	; 0
    1a8c:	e6 95       	lsr	r30
    1a8e:	00 1c       	adc	r0, r0
    1a90:	ca f7       	brpl	.-14     	; 0x1a84 <__divsf3_pse+0x2c>
    1a92:	2b d0       	rcall	.+86     	; 0x1aea <__divsf3_pse+0x92>
    1a94:	fe 2f       	mov	r31, r30
    1a96:	29 d0       	rcall	.+82     	; 0x1aea <__divsf3_pse+0x92>
    1a98:	66 0f       	add	r22, r22
    1a9a:	77 1f       	adc	r23, r23
    1a9c:	88 1f       	adc	r24, r24
    1a9e:	bb 1f       	adc	r27, r27
    1aa0:	26 17       	cp	r18, r22
    1aa2:	37 07       	cpc	r19, r23
    1aa4:	48 07       	cpc	r20, r24
    1aa6:	ab 07       	cpc	r26, r27
    1aa8:	b0 e8       	ldi	r27, 0x80	; 128
    1aaa:	09 f0       	breq	.+2      	; 0x1aae <__divsf3_pse+0x56>
    1aac:	bb 0b       	sbc	r27, r27
    1aae:	80 2d       	mov	r24, r0
    1ab0:	bf 01       	movw	r22, r30
    1ab2:	ff 27       	eor	r31, r31
    1ab4:	93 58       	subi	r25, 0x83	; 131
    1ab6:	5f 4f       	sbci	r21, 0xFF	; 255
    1ab8:	3a f0       	brmi	.+14     	; 0x1ac8 <__divsf3_pse+0x70>
    1aba:	9e 3f       	cpi	r25, 0xFE	; 254
    1abc:	51 05       	cpc	r21, r1
    1abe:	78 f0       	brcs	.+30     	; 0x1ade <__divsf3_pse+0x86>
    1ac0:	0c 94 fa 0d 	jmp	0x1bf4	; 0x1bf4 <__fp_inf>
    1ac4:	0c 94 45 0e 	jmp	0x1c8a	; 0x1c8a <__fp_szero>
    1ac8:	5f 3f       	cpi	r21, 0xFF	; 255
    1aca:	e4 f3       	brlt	.-8      	; 0x1ac4 <__divsf3_pse+0x6c>
    1acc:	98 3e       	cpi	r25, 0xE8	; 232
    1ace:	d4 f3       	brlt	.-12     	; 0x1ac4 <__divsf3_pse+0x6c>
    1ad0:	86 95       	lsr	r24
    1ad2:	77 95       	ror	r23
    1ad4:	67 95       	ror	r22
    1ad6:	b7 95       	ror	r27
    1ad8:	f7 95       	ror	r31
    1ada:	9f 5f       	subi	r25, 0xFF	; 255
    1adc:	c9 f7       	brne	.-14     	; 0x1ad0 <__divsf3_pse+0x78>
    1ade:	88 0f       	add	r24, r24
    1ae0:	91 1d       	adc	r25, r1
    1ae2:	96 95       	lsr	r25
    1ae4:	87 95       	ror	r24
    1ae6:	97 f9       	bld	r25, 7
    1ae8:	08 95       	ret
    1aea:	e1 e0       	ldi	r30, 0x01	; 1
    1aec:	66 0f       	add	r22, r22
    1aee:	77 1f       	adc	r23, r23
    1af0:	88 1f       	adc	r24, r24
    1af2:	bb 1f       	adc	r27, r27
    1af4:	62 17       	cp	r22, r18
    1af6:	73 07       	cpc	r23, r19
    1af8:	84 07       	cpc	r24, r20
    1afa:	ba 07       	cpc	r27, r26
    1afc:	20 f0       	brcs	.+8      	; 0x1b06 <__divsf3_pse+0xae>
    1afe:	62 1b       	sub	r22, r18
    1b00:	73 0b       	sbc	r23, r19
    1b02:	84 0b       	sbc	r24, r20
    1b04:	ba 0b       	sbc	r27, r26
    1b06:	ee 1f       	adc	r30, r30
    1b08:	88 f7       	brcc	.-30     	; 0x1aec <__divsf3_pse+0x94>
    1b0a:	e0 95       	com	r30
    1b0c:	08 95       	ret

00001b0e <__fixsfsi>:
    1b0e:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <__fixunssfsi>
    1b12:	68 94       	set
    1b14:	b1 11       	cpse	r27, r1
    1b16:	0c 94 45 0e 	jmp	0x1c8a	; 0x1c8a <__fp_szero>
    1b1a:	08 95       	ret

00001b1c <__fixunssfsi>:
    1b1c:	0e 94 2a 0e 	call	0x1c54	; 0x1c54 <__fp_splitA>
    1b20:	88 f0       	brcs	.+34     	; 0x1b44 <__fixunssfsi+0x28>
    1b22:	9f 57       	subi	r25, 0x7F	; 127
    1b24:	98 f0       	brcs	.+38     	; 0x1b4c <__fixunssfsi+0x30>
    1b26:	b9 2f       	mov	r27, r25
    1b28:	99 27       	eor	r25, r25
    1b2a:	b7 51       	subi	r27, 0x17	; 23
    1b2c:	b0 f0       	brcs	.+44     	; 0x1b5a <__fixunssfsi+0x3e>
    1b2e:	e1 f0       	breq	.+56     	; 0x1b68 <__fixunssfsi+0x4c>
    1b30:	66 0f       	add	r22, r22
    1b32:	77 1f       	adc	r23, r23
    1b34:	88 1f       	adc	r24, r24
    1b36:	99 1f       	adc	r25, r25
    1b38:	1a f0       	brmi	.+6      	; 0x1b40 <__fixunssfsi+0x24>
    1b3a:	ba 95       	dec	r27
    1b3c:	c9 f7       	brne	.-14     	; 0x1b30 <__fixunssfsi+0x14>
    1b3e:	14 c0       	rjmp	.+40     	; 0x1b68 <__fixunssfsi+0x4c>
    1b40:	b1 30       	cpi	r27, 0x01	; 1
    1b42:	91 f0       	breq	.+36     	; 0x1b68 <__fixunssfsi+0x4c>
    1b44:	0e 94 44 0e 	call	0x1c88	; 0x1c88 <__fp_zero>
    1b48:	b1 e0       	ldi	r27, 0x01	; 1
    1b4a:	08 95       	ret
    1b4c:	0c 94 44 0e 	jmp	0x1c88	; 0x1c88 <__fp_zero>
    1b50:	67 2f       	mov	r22, r23
    1b52:	78 2f       	mov	r23, r24
    1b54:	88 27       	eor	r24, r24
    1b56:	b8 5f       	subi	r27, 0xF8	; 248
    1b58:	39 f0       	breq	.+14     	; 0x1b68 <__fixunssfsi+0x4c>
    1b5a:	b9 3f       	cpi	r27, 0xF9	; 249
    1b5c:	cc f3       	brlt	.-14     	; 0x1b50 <__fixunssfsi+0x34>
    1b5e:	86 95       	lsr	r24
    1b60:	77 95       	ror	r23
    1b62:	67 95       	ror	r22
    1b64:	b3 95       	inc	r27
    1b66:	d9 f7       	brne	.-10     	; 0x1b5e <__fixunssfsi+0x42>
    1b68:	3e f4       	brtc	.+14     	; 0x1b78 <__fixunssfsi+0x5c>
    1b6a:	90 95       	com	r25
    1b6c:	80 95       	com	r24
    1b6e:	70 95       	com	r23
    1b70:	61 95       	neg	r22
    1b72:	7f 4f       	sbci	r23, 0xFF	; 255
    1b74:	8f 4f       	sbci	r24, 0xFF	; 255
    1b76:	9f 4f       	sbci	r25, 0xFF	; 255
    1b78:	08 95       	ret

00001b7a <__floatunsisf>:
    1b7a:	e8 94       	clt
    1b7c:	09 c0       	rjmp	.+18     	; 0x1b90 <__floatsisf+0x12>

00001b7e <__floatsisf>:
    1b7e:	97 fb       	bst	r25, 7
    1b80:	3e f4       	brtc	.+14     	; 0x1b90 <__floatsisf+0x12>
    1b82:	90 95       	com	r25
    1b84:	80 95       	com	r24
    1b86:	70 95       	com	r23
    1b88:	61 95       	neg	r22
    1b8a:	7f 4f       	sbci	r23, 0xFF	; 255
    1b8c:	8f 4f       	sbci	r24, 0xFF	; 255
    1b8e:	9f 4f       	sbci	r25, 0xFF	; 255
    1b90:	99 23       	and	r25, r25
    1b92:	a9 f0       	breq	.+42     	; 0x1bbe <__floatsisf+0x40>
    1b94:	f9 2f       	mov	r31, r25
    1b96:	96 e9       	ldi	r25, 0x96	; 150
    1b98:	bb 27       	eor	r27, r27
    1b9a:	93 95       	inc	r25
    1b9c:	f6 95       	lsr	r31
    1b9e:	87 95       	ror	r24
    1ba0:	77 95       	ror	r23
    1ba2:	67 95       	ror	r22
    1ba4:	b7 95       	ror	r27
    1ba6:	f1 11       	cpse	r31, r1
    1ba8:	f8 cf       	rjmp	.-16     	; 0x1b9a <__floatsisf+0x1c>
    1baa:	fa f4       	brpl	.+62     	; 0x1bea <__floatsisf+0x6c>
    1bac:	bb 0f       	add	r27, r27
    1bae:	11 f4       	brne	.+4      	; 0x1bb4 <__floatsisf+0x36>
    1bb0:	60 ff       	sbrs	r22, 0
    1bb2:	1b c0       	rjmp	.+54     	; 0x1bea <__floatsisf+0x6c>
    1bb4:	6f 5f       	subi	r22, 0xFF	; 255
    1bb6:	7f 4f       	sbci	r23, 0xFF	; 255
    1bb8:	8f 4f       	sbci	r24, 0xFF	; 255
    1bba:	9f 4f       	sbci	r25, 0xFF	; 255
    1bbc:	16 c0       	rjmp	.+44     	; 0x1bea <__floatsisf+0x6c>
    1bbe:	88 23       	and	r24, r24
    1bc0:	11 f0       	breq	.+4      	; 0x1bc6 <__floatsisf+0x48>
    1bc2:	96 e9       	ldi	r25, 0x96	; 150
    1bc4:	11 c0       	rjmp	.+34     	; 0x1be8 <__floatsisf+0x6a>
    1bc6:	77 23       	and	r23, r23
    1bc8:	21 f0       	breq	.+8      	; 0x1bd2 <__floatsisf+0x54>
    1bca:	9e e8       	ldi	r25, 0x8E	; 142
    1bcc:	87 2f       	mov	r24, r23
    1bce:	76 2f       	mov	r23, r22
    1bd0:	05 c0       	rjmp	.+10     	; 0x1bdc <__floatsisf+0x5e>
    1bd2:	66 23       	and	r22, r22
    1bd4:	71 f0       	breq	.+28     	; 0x1bf2 <__floatsisf+0x74>
    1bd6:	96 e8       	ldi	r25, 0x86	; 134
    1bd8:	86 2f       	mov	r24, r22
    1bda:	70 e0       	ldi	r23, 0x00	; 0
    1bdc:	60 e0       	ldi	r22, 0x00	; 0
    1bde:	2a f0       	brmi	.+10     	; 0x1bea <__floatsisf+0x6c>
    1be0:	9a 95       	dec	r25
    1be2:	66 0f       	add	r22, r22
    1be4:	77 1f       	adc	r23, r23
    1be6:	88 1f       	adc	r24, r24
    1be8:	da f7       	brpl	.-10     	; 0x1be0 <__floatsisf+0x62>
    1bea:	88 0f       	add	r24, r24
    1bec:	96 95       	lsr	r25
    1bee:	87 95       	ror	r24
    1bf0:	97 f9       	bld	r25, 7
    1bf2:	08 95       	ret

00001bf4 <__fp_inf>:
    1bf4:	97 f9       	bld	r25, 7
    1bf6:	9f 67       	ori	r25, 0x7F	; 127
    1bf8:	80 e8       	ldi	r24, 0x80	; 128
    1bfa:	70 e0       	ldi	r23, 0x00	; 0
    1bfc:	60 e0       	ldi	r22, 0x00	; 0
    1bfe:	08 95       	ret

00001c00 <__fp_nan>:
    1c00:	9f ef       	ldi	r25, 0xFF	; 255
    1c02:	80 ec       	ldi	r24, 0xC0	; 192
    1c04:	08 95       	ret

00001c06 <__fp_pscA>:
    1c06:	00 24       	eor	r0, r0
    1c08:	0a 94       	dec	r0
    1c0a:	16 16       	cp	r1, r22
    1c0c:	17 06       	cpc	r1, r23
    1c0e:	18 06       	cpc	r1, r24
    1c10:	09 06       	cpc	r0, r25
    1c12:	08 95       	ret

00001c14 <__fp_pscB>:
    1c14:	00 24       	eor	r0, r0
    1c16:	0a 94       	dec	r0
    1c18:	12 16       	cp	r1, r18
    1c1a:	13 06       	cpc	r1, r19
    1c1c:	14 06       	cpc	r1, r20
    1c1e:	05 06       	cpc	r0, r21
    1c20:	08 95       	ret

00001c22 <__fp_round>:
    1c22:	09 2e       	mov	r0, r25
    1c24:	03 94       	inc	r0
    1c26:	00 0c       	add	r0, r0
    1c28:	11 f4       	brne	.+4      	; 0x1c2e <__fp_round+0xc>
    1c2a:	88 23       	and	r24, r24
    1c2c:	52 f0       	brmi	.+20     	; 0x1c42 <__fp_round+0x20>
    1c2e:	bb 0f       	add	r27, r27
    1c30:	40 f4       	brcc	.+16     	; 0x1c42 <__fp_round+0x20>
    1c32:	bf 2b       	or	r27, r31
    1c34:	11 f4       	brne	.+4      	; 0x1c3a <__fp_round+0x18>
    1c36:	60 ff       	sbrs	r22, 0
    1c38:	04 c0       	rjmp	.+8      	; 0x1c42 <__fp_round+0x20>
    1c3a:	6f 5f       	subi	r22, 0xFF	; 255
    1c3c:	7f 4f       	sbci	r23, 0xFF	; 255
    1c3e:	8f 4f       	sbci	r24, 0xFF	; 255
    1c40:	9f 4f       	sbci	r25, 0xFF	; 255
    1c42:	08 95       	ret

00001c44 <__fp_split3>:
    1c44:	57 fd       	sbrc	r21, 7
    1c46:	90 58       	subi	r25, 0x80	; 128
    1c48:	44 0f       	add	r20, r20
    1c4a:	55 1f       	adc	r21, r21
    1c4c:	59 f0       	breq	.+22     	; 0x1c64 <__fp_splitA+0x10>
    1c4e:	5f 3f       	cpi	r21, 0xFF	; 255
    1c50:	71 f0       	breq	.+28     	; 0x1c6e <__fp_splitA+0x1a>
    1c52:	47 95       	ror	r20

00001c54 <__fp_splitA>:
    1c54:	88 0f       	add	r24, r24
    1c56:	97 fb       	bst	r25, 7
    1c58:	99 1f       	adc	r25, r25
    1c5a:	61 f0       	breq	.+24     	; 0x1c74 <__fp_splitA+0x20>
    1c5c:	9f 3f       	cpi	r25, 0xFF	; 255
    1c5e:	79 f0       	breq	.+30     	; 0x1c7e <__fp_splitA+0x2a>
    1c60:	87 95       	ror	r24
    1c62:	08 95       	ret
    1c64:	12 16       	cp	r1, r18
    1c66:	13 06       	cpc	r1, r19
    1c68:	14 06       	cpc	r1, r20
    1c6a:	55 1f       	adc	r21, r21
    1c6c:	f2 cf       	rjmp	.-28     	; 0x1c52 <__fp_split3+0xe>
    1c6e:	46 95       	lsr	r20
    1c70:	f1 df       	rcall	.-30     	; 0x1c54 <__fp_splitA>
    1c72:	08 c0       	rjmp	.+16     	; 0x1c84 <__fp_splitA+0x30>
    1c74:	16 16       	cp	r1, r22
    1c76:	17 06       	cpc	r1, r23
    1c78:	18 06       	cpc	r1, r24
    1c7a:	99 1f       	adc	r25, r25
    1c7c:	f1 cf       	rjmp	.-30     	; 0x1c60 <__fp_splitA+0xc>
    1c7e:	86 95       	lsr	r24
    1c80:	71 05       	cpc	r23, r1
    1c82:	61 05       	cpc	r22, r1
    1c84:	08 94       	sec
    1c86:	08 95       	ret

00001c88 <__fp_zero>:
    1c88:	e8 94       	clt

00001c8a <__fp_szero>:
    1c8a:	bb 27       	eor	r27, r27
    1c8c:	66 27       	eor	r22, r22
    1c8e:	77 27       	eor	r23, r23
    1c90:	cb 01       	movw	r24, r22
    1c92:	97 f9       	bld	r25, 7
    1c94:	08 95       	ret

00001c96 <__mulsf3>:
    1c96:	0e 94 5e 0e 	call	0x1cbc	; 0x1cbc <__mulsf3x>
    1c9a:	0c 94 11 0e 	jmp	0x1c22	; 0x1c22 <__fp_round>
    1c9e:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <__fp_pscA>
    1ca2:	38 f0       	brcs	.+14     	; 0x1cb2 <__mulsf3+0x1c>
    1ca4:	0e 94 0a 0e 	call	0x1c14	; 0x1c14 <__fp_pscB>
    1ca8:	20 f0       	brcs	.+8      	; 0x1cb2 <__mulsf3+0x1c>
    1caa:	95 23       	and	r25, r21
    1cac:	11 f0       	breq	.+4      	; 0x1cb2 <__mulsf3+0x1c>
    1cae:	0c 94 fa 0d 	jmp	0x1bf4	; 0x1bf4 <__fp_inf>
    1cb2:	0c 94 00 0e 	jmp	0x1c00	; 0x1c00 <__fp_nan>
    1cb6:	11 24       	eor	r1, r1
    1cb8:	0c 94 45 0e 	jmp	0x1c8a	; 0x1c8a <__fp_szero>

00001cbc <__mulsf3x>:
    1cbc:	0e 94 22 0e 	call	0x1c44	; 0x1c44 <__fp_split3>
    1cc0:	70 f3       	brcs	.-36     	; 0x1c9e <__mulsf3+0x8>

00001cc2 <__mulsf3_pse>:
    1cc2:	95 9f       	mul	r25, r21
    1cc4:	c1 f3       	breq	.-16     	; 0x1cb6 <__mulsf3+0x20>
    1cc6:	95 0f       	add	r25, r21
    1cc8:	50 e0       	ldi	r21, 0x00	; 0
    1cca:	55 1f       	adc	r21, r21
    1ccc:	62 9f       	mul	r22, r18
    1cce:	f0 01       	movw	r30, r0
    1cd0:	72 9f       	mul	r23, r18
    1cd2:	bb 27       	eor	r27, r27
    1cd4:	f0 0d       	add	r31, r0
    1cd6:	b1 1d       	adc	r27, r1
    1cd8:	63 9f       	mul	r22, r19
    1cda:	aa 27       	eor	r26, r26
    1cdc:	f0 0d       	add	r31, r0
    1cde:	b1 1d       	adc	r27, r1
    1ce0:	aa 1f       	adc	r26, r26
    1ce2:	64 9f       	mul	r22, r20
    1ce4:	66 27       	eor	r22, r22
    1ce6:	b0 0d       	add	r27, r0
    1ce8:	a1 1d       	adc	r26, r1
    1cea:	66 1f       	adc	r22, r22
    1cec:	82 9f       	mul	r24, r18
    1cee:	22 27       	eor	r18, r18
    1cf0:	b0 0d       	add	r27, r0
    1cf2:	a1 1d       	adc	r26, r1
    1cf4:	62 1f       	adc	r22, r18
    1cf6:	73 9f       	mul	r23, r19
    1cf8:	b0 0d       	add	r27, r0
    1cfa:	a1 1d       	adc	r26, r1
    1cfc:	62 1f       	adc	r22, r18
    1cfe:	83 9f       	mul	r24, r19
    1d00:	a0 0d       	add	r26, r0
    1d02:	61 1d       	adc	r22, r1
    1d04:	22 1f       	adc	r18, r18
    1d06:	74 9f       	mul	r23, r20
    1d08:	33 27       	eor	r19, r19
    1d0a:	a0 0d       	add	r26, r0
    1d0c:	61 1d       	adc	r22, r1
    1d0e:	23 1f       	adc	r18, r19
    1d10:	84 9f       	mul	r24, r20
    1d12:	60 0d       	add	r22, r0
    1d14:	21 1d       	adc	r18, r1
    1d16:	82 2f       	mov	r24, r18
    1d18:	76 2f       	mov	r23, r22
    1d1a:	6a 2f       	mov	r22, r26
    1d1c:	11 24       	eor	r1, r1
    1d1e:	9f 57       	subi	r25, 0x7F	; 127
    1d20:	50 40       	sbci	r21, 0x00	; 0
    1d22:	9a f0       	brmi	.+38     	; 0x1d4a <__mulsf3_pse+0x88>
    1d24:	f1 f0       	breq	.+60     	; 0x1d62 <__mulsf3_pse+0xa0>
    1d26:	88 23       	and	r24, r24
    1d28:	4a f0       	brmi	.+18     	; 0x1d3c <__mulsf3_pse+0x7a>
    1d2a:	ee 0f       	add	r30, r30
    1d2c:	ff 1f       	adc	r31, r31
    1d2e:	bb 1f       	adc	r27, r27
    1d30:	66 1f       	adc	r22, r22
    1d32:	77 1f       	adc	r23, r23
    1d34:	88 1f       	adc	r24, r24
    1d36:	91 50       	subi	r25, 0x01	; 1
    1d38:	50 40       	sbci	r21, 0x00	; 0
    1d3a:	a9 f7       	brne	.-22     	; 0x1d26 <__mulsf3_pse+0x64>
    1d3c:	9e 3f       	cpi	r25, 0xFE	; 254
    1d3e:	51 05       	cpc	r21, r1
    1d40:	80 f0       	brcs	.+32     	; 0x1d62 <__mulsf3_pse+0xa0>
    1d42:	0c 94 fa 0d 	jmp	0x1bf4	; 0x1bf4 <__fp_inf>
    1d46:	0c 94 45 0e 	jmp	0x1c8a	; 0x1c8a <__fp_szero>
    1d4a:	5f 3f       	cpi	r21, 0xFF	; 255
    1d4c:	e4 f3       	brlt	.-8      	; 0x1d46 <__mulsf3_pse+0x84>
    1d4e:	98 3e       	cpi	r25, 0xE8	; 232
    1d50:	d4 f3       	brlt	.-12     	; 0x1d46 <__mulsf3_pse+0x84>
    1d52:	86 95       	lsr	r24
    1d54:	77 95       	ror	r23
    1d56:	67 95       	ror	r22
    1d58:	b7 95       	ror	r27
    1d5a:	f7 95       	ror	r31
    1d5c:	e7 95       	ror	r30
    1d5e:	9f 5f       	subi	r25, 0xFF	; 255
    1d60:	c1 f7       	brne	.-16     	; 0x1d52 <__mulsf3_pse+0x90>
    1d62:	fe 2b       	or	r31, r30
    1d64:	88 0f       	add	r24, r24
    1d66:	91 1d       	adc	r25, r1
    1d68:	96 95       	lsr	r25
    1d6a:	87 95       	ror	r24
    1d6c:	97 f9       	bld	r25, 7
    1d6e:	08 95       	ret

00001d70 <do_rand>:
    1d70:	8f 92       	push	r8
    1d72:	9f 92       	push	r9
    1d74:	af 92       	push	r10
    1d76:	bf 92       	push	r11
    1d78:	cf 92       	push	r12
    1d7a:	df 92       	push	r13
    1d7c:	ef 92       	push	r14
    1d7e:	ff 92       	push	r15
    1d80:	cf 93       	push	r28
    1d82:	df 93       	push	r29
    1d84:	ec 01       	movw	r28, r24
    1d86:	68 81       	ld	r22, Y
    1d88:	79 81       	ldd	r23, Y+1	; 0x01
    1d8a:	8a 81       	ldd	r24, Y+2	; 0x02
    1d8c:	9b 81       	ldd	r25, Y+3	; 0x03
    1d8e:	61 15       	cp	r22, r1
    1d90:	71 05       	cpc	r23, r1
    1d92:	81 05       	cpc	r24, r1
    1d94:	91 05       	cpc	r25, r1
    1d96:	21 f4       	brne	.+8      	; 0x1da0 <do_rand+0x30>
    1d98:	64 e2       	ldi	r22, 0x24	; 36
    1d9a:	79 ed       	ldi	r23, 0xD9	; 217
    1d9c:	8b e5       	ldi	r24, 0x5B	; 91
    1d9e:	97 e0       	ldi	r25, 0x07	; 7
    1da0:	2d e1       	ldi	r18, 0x1D	; 29
    1da2:	33 ef       	ldi	r19, 0xF3	; 243
    1da4:	41 e0       	ldi	r20, 0x01	; 1
    1da6:	50 e0       	ldi	r21, 0x00	; 0
    1da8:	0e 94 2a 0f 	call	0x1e54	; 0x1e54 <__divmodsi4>
    1dac:	49 01       	movw	r8, r18
    1dae:	5a 01       	movw	r10, r20
    1db0:	9b 01       	movw	r18, r22
    1db2:	ac 01       	movw	r20, r24
    1db4:	a7 ea       	ldi	r26, 0xA7	; 167
    1db6:	b1 e4       	ldi	r27, 0x41	; 65
    1db8:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <__muluhisi3>
    1dbc:	6b 01       	movw	r12, r22
    1dbe:	7c 01       	movw	r14, r24
    1dc0:	ac ee       	ldi	r26, 0xEC	; 236
    1dc2:	b4 ef       	ldi	r27, 0xF4	; 244
    1dc4:	a5 01       	movw	r20, r10
    1dc6:	94 01       	movw	r18, r8
    1dc8:	0e 94 57 0f 	call	0x1eae	; 0x1eae <__mulohisi3>
    1dcc:	dc 01       	movw	r26, r24
    1dce:	cb 01       	movw	r24, r22
    1dd0:	8c 0d       	add	r24, r12
    1dd2:	9d 1d       	adc	r25, r13
    1dd4:	ae 1d       	adc	r26, r14
    1dd6:	bf 1d       	adc	r27, r15
    1dd8:	b7 ff       	sbrs	r27, 7
    1dda:	03 c0       	rjmp	.+6      	; 0x1de2 <do_rand+0x72>
    1ddc:	01 97       	sbiw	r24, 0x01	; 1
    1dde:	a1 09       	sbc	r26, r1
    1de0:	b0 48       	sbci	r27, 0x80	; 128
    1de2:	88 83       	st	Y, r24
    1de4:	99 83       	std	Y+1, r25	; 0x01
    1de6:	aa 83       	std	Y+2, r26	; 0x02
    1de8:	bb 83       	std	Y+3, r27	; 0x03
    1dea:	9f 77       	andi	r25, 0x7F	; 127
    1dec:	df 91       	pop	r29
    1dee:	cf 91       	pop	r28
    1df0:	ff 90       	pop	r15
    1df2:	ef 90       	pop	r14
    1df4:	df 90       	pop	r13
    1df6:	cf 90       	pop	r12
    1df8:	bf 90       	pop	r11
    1dfa:	af 90       	pop	r10
    1dfc:	9f 90       	pop	r9
    1dfe:	8f 90       	pop	r8
    1e00:	08 95       	ret

00001e02 <rand_r>:
    1e02:	0e 94 b8 0e 	call	0x1d70	; 0x1d70 <do_rand>
    1e06:	08 95       	ret

00001e08 <rand>:
    1e08:	89 e0       	ldi	r24, 0x09	; 9
    1e0a:	91 e0       	ldi	r25, 0x01	; 1
    1e0c:	0e 94 b8 0e 	call	0x1d70	; 0x1d70 <do_rand>
    1e10:	08 95       	ret

00001e12 <srand>:
    1e12:	a0 e0       	ldi	r26, 0x00	; 0
    1e14:	b0 e0       	ldi	r27, 0x00	; 0
    1e16:	80 93 09 01 	sts	0x0109, r24	; 0x800109 <next>
    1e1a:	90 93 0a 01 	sts	0x010A, r25	; 0x80010a <next+0x1>
    1e1e:	a0 93 0b 01 	sts	0x010B, r26	; 0x80010b <next+0x2>
    1e22:	b0 93 0c 01 	sts	0x010C, r27	; 0x80010c <next+0x3>
    1e26:	08 95       	ret

00001e28 <eeprom_read_byte>:
    1e28:	f9 99       	sbic	0x1f, 1	; 31
    1e2a:	fe cf       	rjmp	.-4      	; 0x1e28 <eeprom_read_byte>
    1e2c:	92 bd       	out	0x22, r25	; 34
    1e2e:	81 bd       	out	0x21, r24	; 33
    1e30:	f8 9a       	sbi	0x1f, 0	; 31
    1e32:	99 27       	eor	r25, r25
    1e34:	80 b5       	in	r24, 0x20	; 32
    1e36:	08 95       	ret

00001e38 <eeprom_write_byte>:
    1e38:	26 2f       	mov	r18, r22

00001e3a <eeprom_write_r18>:
    1e3a:	f9 99       	sbic	0x1f, 1	; 31
    1e3c:	fe cf       	rjmp	.-4      	; 0x1e3a <eeprom_write_r18>
    1e3e:	1f ba       	out	0x1f, r1	; 31
    1e40:	92 bd       	out	0x22, r25	; 34
    1e42:	81 bd       	out	0x21, r24	; 33
    1e44:	20 bd       	out	0x20, r18	; 32
    1e46:	0f b6       	in	r0, 0x3f	; 63
    1e48:	f8 94       	cli
    1e4a:	fa 9a       	sbi	0x1f, 2	; 31
    1e4c:	f9 9a       	sbi	0x1f, 1	; 31
    1e4e:	0f be       	out	0x3f, r0	; 63
    1e50:	01 96       	adiw	r24, 0x01	; 1
    1e52:	08 95       	ret

00001e54 <__divmodsi4>:
    1e54:	05 2e       	mov	r0, r21
    1e56:	97 fb       	bst	r25, 7
    1e58:	1e f4       	brtc	.+6      	; 0x1e60 <__divmodsi4+0xc>
    1e5a:	00 94       	com	r0
    1e5c:	0e 94 41 0f 	call	0x1e82	; 0x1e82 <__negsi2>
    1e60:	57 fd       	sbrc	r21, 7
    1e62:	07 d0       	rcall	.+14     	; 0x1e72 <__divmodsi4_neg2>
    1e64:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <__udivmodsi4>
    1e68:	07 fc       	sbrc	r0, 7
    1e6a:	03 d0       	rcall	.+6      	; 0x1e72 <__divmodsi4_neg2>
    1e6c:	4e f4       	brtc	.+18     	; 0x1e80 <__divmodsi4_exit>
    1e6e:	0c 94 41 0f 	jmp	0x1e82	; 0x1e82 <__negsi2>

00001e72 <__divmodsi4_neg2>:
    1e72:	50 95       	com	r21
    1e74:	40 95       	com	r20
    1e76:	30 95       	com	r19
    1e78:	21 95       	neg	r18
    1e7a:	3f 4f       	sbci	r19, 0xFF	; 255
    1e7c:	4f 4f       	sbci	r20, 0xFF	; 255
    1e7e:	5f 4f       	sbci	r21, 0xFF	; 255

00001e80 <__divmodsi4_exit>:
    1e80:	08 95       	ret

00001e82 <__negsi2>:
    1e82:	90 95       	com	r25
    1e84:	80 95       	com	r24
    1e86:	70 95       	com	r23
    1e88:	61 95       	neg	r22
    1e8a:	7f 4f       	sbci	r23, 0xFF	; 255
    1e8c:	8f 4f       	sbci	r24, 0xFF	; 255
    1e8e:	9f 4f       	sbci	r25, 0xFF	; 255
    1e90:	08 95       	ret

00001e92 <__muluhisi3>:
    1e92:	0e 94 85 0c 	call	0x190a	; 0x190a <__umulhisi3>
    1e96:	a5 9f       	mul	r26, r21
    1e98:	90 0d       	add	r25, r0
    1e9a:	b4 9f       	mul	r27, r20
    1e9c:	90 0d       	add	r25, r0
    1e9e:	a4 9f       	mul	r26, r20
    1ea0:	80 0d       	add	r24, r0
    1ea2:	91 1d       	adc	r25, r1
    1ea4:	11 24       	eor	r1, r1
    1ea6:	08 95       	ret

00001ea8 <__mulshisi3>:
    1ea8:	b7 ff       	sbrs	r27, 7
    1eaa:	0c 94 49 0f 	jmp	0x1e92	; 0x1e92 <__muluhisi3>

00001eae <__mulohisi3>:
    1eae:	0e 94 49 0f 	call	0x1e92	; 0x1e92 <__muluhisi3>
    1eb2:	82 1b       	sub	r24, r18
    1eb4:	93 0b       	sbc	r25, r19
    1eb6:	08 95       	ret

00001eb8 <__udivmodsi4>:
    1eb8:	a1 e2       	ldi	r26, 0x21	; 33
    1eba:	1a 2e       	mov	r1, r26
    1ebc:	aa 1b       	sub	r26, r26
    1ebe:	bb 1b       	sub	r27, r27
    1ec0:	fd 01       	movw	r30, r26
    1ec2:	0d c0       	rjmp	.+26     	; 0x1ede <__udivmodsi4_ep>

00001ec4 <__udivmodsi4_loop>:
    1ec4:	aa 1f       	adc	r26, r26
    1ec6:	bb 1f       	adc	r27, r27
    1ec8:	ee 1f       	adc	r30, r30
    1eca:	ff 1f       	adc	r31, r31
    1ecc:	a2 17       	cp	r26, r18
    1ece:	b3 07       	cpc	r27, r19
    1ed0:	e4 07       	cpc	r30, r20
    1ed2:	f5 07       	cpc	r31, r21
    1ed4:	20 f0       	brcs	.+8      	; 0x1ede <__udivmodsi4_ep>
    1ed6:	a2 1b       	sub	r26, r18
    1ed8:	b3 0b       	sbc	r27, r19
    1eda:	e4 0b       	sbc	r30, r20
    1edc:	f5 0b       	sbc	r31, r21

00001ede <__udivmodsi4_ep>:
    1ede:	66 1f       	adc	r22, r22
    1ee0:	77 1f       	adc	r23, r23
    1ee2:	88 1f       	adc	r24, r24
    1ee4:	99 1f       	adc	r25, r25
    1ee6:	1a 94       	dec	r1
    1ee8:	69 f7       	brne	.-38     	; 0x1ec4 <__udivmodsi4_loop>
    1eea:	60 95       	com	r22
    1eec:	70 95       	com	r23
    1eee:	80 95       	com	r24
    1ef0:	90 95       	com	r25
    1ef2:	9b 01       	movw	r18, r22
    1ef4:	ac 01       	movw	r20, r24
    1ef6:	bd 01       	movw	r22, r26
    1ef8:	cf 01       	movw	r24, r30
    1efa:	08 95       	ret

00001efc <_exit>:
    1efc:	f8 94       	cli

00001efe <__stop_program>:
    1efe:	ff cf       	rjmp	.-2      	; 0x1efe <__stop_program>
